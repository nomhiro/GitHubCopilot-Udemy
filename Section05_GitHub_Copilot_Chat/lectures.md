# GitHub Copilot Chat & エージェントモード（31%の一部）

## 対応プラン
| 機能 | Free | Pro | Business | Enterprise |
|------|:----:|:---:|:--------:|:----------:|
| Copilot Chat（基本） | ○* | ○ | ○ | ○ |
| スラッシュコマンド | ○* | ○ | ○ | ○ |
| エージェントモード | - | ○ | ○ | ○ |
| GitHub.comでのChat | - | ○ | ○ | ○ |
| カスタムモデル（BYOK） | - | - | - | ○ |
| カスタムエージェント | - | - | ○ | ○ |
| 組織レベルカスタム指示 | - | - | - | ○ |

*Free: 月50メッセージまで

## 参照リソース
- [GitHub Copilot の高度な機能 - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/advanced-github-copilot/2-advanced-github-copilot-features)
- [GitHub Copilot の応用手法 - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/advanced-github-copilot/4-applied-copilot-techniques)
- [GitHub Copilot チャット - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/github-copilot-across-environments/3-git-hub-copilot-chat)
- [GitHub Copilot エージェント モードとは - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/github-copilot-agent-mode/2-what-is-agent-mode)
- [GitHub Copilot エージェントモードの自律開発支援 - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/github-copilot-agent-mode/3-explore-the-power)
- [Copilot チャットでの GitHub MCP サーバーの使用 - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/mcp-server/4-use-github-copilot-chat)

---

## レクチャー1: Copilot Chatの概要と効果的なユースケース
**時間目安: 10分**

### GitHub Copilotの高度な機能

コードを操作するときは、ライブラリやフレームワークのドキュメントに加えて、プロジェクトのドキュメントを確認する必要があります。GitHub Copilot には、これらのタスクをより簡単かつ効率的にできる高度な機能がいくつかあります。

#### 基本（ゴーストテキスト）

GitHub Copilot が有効になっていると、提案が「ゴーストテキスト」として表示されます。

| 操作 | 説明 |
|------|------|
| Tab キー | ゴーストテキストを受け入れる |
| 無視 | 何もせずに入力を続けると提案は消える |
| コンテキスト | 開いているファイルを既定でコンテキストとして使用 |

#### GitHub Copilot とのチャット

Visual Studio Code では、左側のサイドバーにあるチャットアイコンをクリックして、専用のペインでチャットインターフェイスを開くことができます。このペインで、現在作業中のコードや、他のソフトウェア関連の疑問について質問できます。

#### インラインチャットの使用

専用のチャットペインに加えて、コードを離れることなく GitHub Copilot と対話できるインラインチャットも使用できます。

| OS | ショートカット |
|----|---------------|
| Windows | **Ctrl + i** |
| Mac | **Command + i** |

**利点**: コンテキストを切り替えるために別のウィンドウに移動する必要がなく、提案と対話はコードの近くで行われます。

### GitHub Copilot Chatの効果的なユースケース

GitHub Copilot Chat は特定のシナリオで特に役立ちます。

#### 1. 複雑なコード生成

複雑なアルゴリズムやデータ構造を実装する必要がある場合、または特定の設計パターンの定型コードを生成する必要がある場合に、Copilot Chat はプロセスの効率化に役立ちます。

**活用例**:
- 複雑な正規表現の作成
- 詳細な SQL クエリの構築
- Python でのバブル並べ替えなどの高度なデータ構造の開発

#### 2. デバッグの支援

コードでエラーが発生した場合、Copilot Chat はエラー メッセージの分析や潜在的な修正の提案に役立ちます。

**使用方法**:
1. エラーを含むコードの部分を選択（ハイライト）
2. 右クリックして「Copilot」を選択
3. インラインチャットで質問

**質問例**:
```
このメソッドで `NullReferenceException` を取得しています。デバッグを手伝ってもらえますか?
```

Copilot は以下を支援します:
- 論理エラーの特定
- コードの問題のあるセクションの詳細な説明
- 潜在的な修正の提案

#### 3. コードの説明

Copilot Chat を使用して、複雑なコード スニペットをより深く理解することができます。

**機能**:
- コードを簡単な用語に分解
- 未知のコードの目的と機能を説明
- ベスト プラクティスと潜在的な最適化に関する分析情報を提供

**質問例**:
```
Python でこの async/await コードがどのように機能するか説明してもらえますか?
```

---

## レクチャー2: スラッシュコマンド一覧と使い方
**時間目安: 12分**

### スラッシュコマンド

チャットウィンドウ内で、またはインラインチャットの使用時に、スラッシュコマンドを使用できます。これらのコマンドにより、GitHub Copilot は一般的な開発タスクをすばやく解決するために特定の意図を使用できます。

| コマンド | 用途 |
|---------|------|
| `/tests` | テストの記述に役立つ |
| `/docs` | ドキュメントの記述を目的としている |
| `/fix` | 指定したコードまたは選択したコードの問題を修正 |
| `/doc` | 指定したコードまたは選択したコードにコメントを追加 |
| `/explain` | コードに関する説明を取得 |
| `/generate` | 指定された質問に回答するコードを生成 |
| `/help` | Copilot チャットの使用方法に関するヘルプを取得 |
| `/optimize` | 選択したコードのランタイムを分析して改善 |

チャットペインまたはインラインチャットでスラッシュ（/）を入力すると、使用可能なすべてのスラッシュコマンドを含むドロップダウンメニューが表示されます。

スラッシュコマンドを使用すると、GitHub Copilotとの対話が簡単になり、長いプロンプトを記述せずに、より適切な応答を取得できます。

### チャットエージェント

Visual Studio Code には、GitHub Copilot と対話できる「チャットエージェント」という機能があります。これらのエージェントを使用すると、特定のコンテキストを使用して質問できます。

| エージェント | 説明 | 使用例 |
|------------|------|--------|
| `@terminal` | ターミナルと対話するのに役立つ | ターミナルコマンドに関する質問 |
| `@workspace` | ワークスペース全体を認識している | `@workspace how can I package this project?` |
| `@vscode` | Visual Studio Code に関連する質問に対応 | IDE 設定の変更やデバッグ方法について質問 |
| `@file` | 特定のファイルの内容に焦点を当てる | `@file この関数を main.py でリファクタリングできますか?` |
| `@directory` | 特定のディレクトリの内容を考慮 | `@directory utils ディレクトリ内のスクリプトを最適化する方法` |

エージェントを使用するには、質問の前にエージェント名を付けます。

### @workspace エージェントの詳細

`@workspace` エージェントを使用すると、Copilot にするあらゆる質問のコンテキストをプロジェクト全体に拡張できます。

**活用例**:
- プロジェクト全体の情報を使用して、プロジェクトに適したコードをすぐに生成
- コードベース全体に関する回答を取得

#### @workspace /new スマートアクション

`@workspace /new` を使用すると、要件に基づいてまったく新しいプロジェクトをゼロから生成できます。

**使用例**:
```
@workspace /new は高度な計算のために新しい html ファイル ページと JavaScript を生成します
```

**手順**:
1. 上記のようにプロンプトを入力
2. 「ワークスペースを作成」をクリック
3. コード生成が進み、リクエストしたコード付きの新しいプロジェクトが作成される

### @vscode エージェント

`@vscode` エージェントを使用して、IDE 内で設定をデバッグまたは変更する方法など、Visual Studio Code に関連する質問ができます。

**質問例**:
```
@vscode テーマを変更するにはどうすればよいですか？
@vscode デバッグ設定を追加するにはどうすればよいですか？
```

### @terminal エージェント

`@terminal` エージェントは、コマンドライン関連の質問に役立ちます。

**質問例**:
- ディレクトリ内の最大のファイルを見つける
- 最後に実行したコマンドを説明する

---

## レクチャー3: 【ハンズオン】Chatを使ったコード説明・生成
**時間目安: 15分**

### 暗黙的なプロンプト

GitHub Copilot ガイダンスを取得するためのプロンプトでは、事前に作成されたプロンプトを暗黙的に提供する機能を利用できます。

**例: バグのあるPythonコードの修正**

```python
with open("file.txt", "r") as file:
    # Read the file and print the content
    contents = file.read
```

このコードにはバグがあります（`file.read`の後にかっこがない）。コードを選択し、インラインチャットを開いて（Windows: **Ctrl + I**、Mac: **Command + i**）`/fix`スラッシュコマンドを入力すると、Copilotがコードの修正を提案します。

### 選択的コンテキスト

GitHub Copilotは、作業中のコンテキストに基づいて提案をカスタマイズできます。ワークスペース全体またはターミナル出力に基づいて提案を提供するように依頼できます。

**Dockerfileの作成例**:
```text
@workspace help me create a Dockerfile to package this project but make sure you are using a Virtual Environment for Python.
```

**注意**: `@workspace`で具体的に指定することもできますが、GitHub Copilotはテキストエディターで開いているファイルを追加のコンテキストとして使用します。提案が探しているものと一致しない場合は、プロンプトの文言を変更して、より具体的に指示できます。

---

## レクチャー4: Copilot Chatのパフォーマンス向上テクニック
**時間目安: 10分**

### GitHub Copilot Chat の応答を改善する方法

特定の主要な機能を使用して、GitHub Copilot Chat の応答の品質と関連性を大幅に向上させることができます。

### スコープの参照

GitHub Copilot Chat によって提供される応答の精度と関連性を高めるために、参照を使用して質問のスコープを適切に設定することが重要です。

#### ファイル参照

質問内の特定のファイルを指定するには、ファイル名の前に `#file:` を追加します。

**使用方法**:
1. `#file:` コマンドを入力
2. 表示されるファイル一覧から選択
3. 質問内で `#file:controller.js` のように直接参照

**例**:
```
#file:controller.js このファイルのエラーハンドリングを改善するにはどうすればよいですか？
```

この機能は、応答を生成するときに、そのファイルの内容に焦点を当てるように Copilot Chat に指示します。

#### 環境参照（@workspace）

`@workspace` を使用して、ソリューション全体またはワークスペースを参照できます。

**機能**:
- Visual Studio IDE で現在開かれているプロジェクトと構成のより広範なコンテキストを考慮
- 最も関連性の高い情報を見つけるためにソリューション全体を検討

**使用例**:
```
@workspace 計算関数はどこにありますか
```

### コンテキスト設定のベストプラクティス

| テクニック | 効果 | 使用場面 |
|-----------|------|---------|
| `#file:` でファイル指定 | 特定ファイルに焦点を当てた回答 | 特定ファイルの改善・デバッグ |
| `@workspace` でプロジェクト全体参照 | プロジェクト構造を考慮した回答 | アーキテクチャに関する質問 |
| コードを選択してから質問 | 選択したコードに特化した回答 | コードの説明・修正 |
| 複数ファイルを開いておく | 関連ファイルのコンテキストを利用 | 関連コンポーネント間の整合性確保 |

### 効果的なプロンプトの構造

より良い応答を得るためのプロンプト構造:

1. **コンテキストを指定**: `#file:` や `@workspace` を使用
2. **具体的な要求**: 何をしたいか明確に記述
3. **制約条件**: 必要に応じて制約を追加

**悪い例**:
```
このコードを修正して
```

**良い例**:
```
#file:userService.js のgetUser関数で発生しているnull参照エラーを修正してください。エラーが発生した場合は適切なエラーメッセージを返すようにしてください。
```

---

## レクチャー5: Copilot Chatの制限事項とベストプラクティス
**時間目安: 10分**

### モデルの選択とプレミアム機能

GitHub Copilot Chat には、開発ワークフローを最適化するためのさまざまな AI モデルが用意されています。一部の環境には、特定のニーズに基づいてさまざまな機能レベルから選択できるモデル選択オプションが用意されています。

#### 標準モデル（GPT-4o）

| 項目 | 内容 |
|------|------|
| **PRU消費** | 要求ごとに 1 PRU |
| **特徴** | ほとんどの開発タスクに対して高速で信頼性の高い応答を提供 |
| **最適な用途** | 日常的なコーディング支援、コードの説明、基本的なデバッグ |

**使用例**:
- 単純な関数の生成
- 構文ヘルプ
- 基本的なリファクタリングの提案

#### プレミアムモデル（o1-preview、o1-mini）

| 項目 | 内容 |
|------|------|
| **PRU消費** | 要求ごとに 2 PRU（標準レートの2倍） |
| **特徴** | 複雑な問題に対して強化された推論機能を提供 |
| **最適な用途** | 高度な分析、複雑なアルゴリズム、アーキテクチャの決定 |

**使用例**:
- マルチスレッド コードの高度なデバッグ
- 複雑なアルゴリズム設計
- セキュリティ分析

### PRU（Premium Request Units）について

PRU（プレミアム要求ユニット）は、GitHub Copilot の使用量を測定する単位です。

#### PRU消費量の目安

| 操作タイプ | PRU消費量 |
|-----------|----------|
| 標準モデルでの単純なクエリ | 1 PRU |
| プレミアムモデルでのクエリ | 2 PRU |
| `@workspace` などの高度なエージェント | 2〜5 PRU |
| 複雑なワークスペース分析またはプロジェクト生成 | 2〜5 PRU |

> **注意**: PRU の使用量と制限の現在の詳細については、[GitHub Copilot のドキュメントの要求](https://docs.github.com/en/copilot/concepts/billing/copilot-requests)を参照してください。

### モデル選択のベストプラクティス

| シナリオ | 推奨モデル | 理由 |
|---------|-----------|------|
| 日常的なコーディング | 標準（GPT-4o） | コスト効率が良く、十分な精度 |
| 困難な問題の分析 | プレミアム（o1-preview/o1-mini） | 強化された推論機能が必要 |
| 単純な構文ヘルプ | 標準（GPT-4o） | 高度な推論は不要 |
| セキュリティ分析 | プレミアム（o1-preview/o1-mini） | 詳細な分析が必要 |

### Copilot Chat の制限事項

1. **コンテキストの制限**: 送信できるコードの量には制限がある
2. **トレーニングデータの制限**: 最新のライブラリやフレームワークの情報が含まれていない可能性
3. **精度の限界**: 提案は常に正確とは限らず、レビューが必要
4. **言語サポート**: 一部の言語は他の言語よりサポートが限定的

### ベストプラクティス

1. **提案を常に確認**: 生成されたコードは必ずレビューする
2. **適切なモデルを選択**: タスクの複雑さに応じてモデルを選ぶ
3. **PRU使用量を監視**: 毎月の許容量を意識する
4. **コンテキストを最適化**: 必要な情報のみを提供する
5. **反復的に改善**: 最初の提案が不十分な場合はプロンプトを調整

---

## レクチャー6: フィードバックの共有方法
**時間目安: 5分**

### GitHub Copilot Chat に関するフィードバックの共有

Copilot Chat 統合を使用するほとんどの IDE には、組み込みのフィードバック メカニズムがあります。

### フィードバックボタンの使い方

Visual Studio Code では、GitHub Copilot Chat の提案の冒頭にフィードバック オプションがあります。

#### フィードバックの送信方法

1. **提案の上にマウスポインターを置く**
2. 「thumbs up」ボタンと「thumbs down」ボタンが表示される
3. 適切なボタンをクリックしてフィードバックを送信

#### フィードバックボタン

| ボタン | 意味 | 使用場面 |
|--------|------|---------|
| 👍 **Thumbs up** | 役に立った | 提案が正確で有用だった場合 |
| 👎 **Thumbs down** | 役に立たなかった | 提案が不正確または不適切だった場合 |

### フィードバックの重要性

#### GitHub にとってのメリット
- 提案の品質向上に役立つデータ収集
- よくある問題パターンの特定
- AI モデルの継続的な改善

#### 開発者にとってのメリット
- より関連性の高い提案を受け取れるようになる
- Copilot の機能改善に貢献できる

### フィードバック送信のベストプラクティス

1. **積極的にフィードバックを送信**: 良い提案も悪い提案も報告
2. **一貫性を保つ**: 同じ基準でフィードバックを提供
3. **具体的な問題を報告**: 明らかに不正確な提案は thumbs down を送信

### フィードバック以外の問題報告

より詳細なフィードバックや問題報告が必要な場合:

1. **GitHub Issues**: [github.com/community/community](https://github.com/community/community) で問題を報告
2. **サポートへの連絡**: GitHub サポートに直接連絡

### まとめ

- フィードバックは Copilot の改善に直接貢献する
- 「thumbs up」と「thumbs down」で簡単に評価できる
- 積極的なフィードバックがより良い提案につながる

---

## レクチャー7: GitHub Copilot エージェントモードの概要
**時間目安: 12分**

### GitHub Copilot エージェントモードとは

GitHub Copilot エージェントモードは、AI 支援型ソフトウェア開発の大きな進歩を表します。シンプルなオートコンプリートスタイルの提案を提供する従来のコーディングアシスタントとは異なり、エージェントモードは**自律的なピアプログラマ**として機能し、開発者がより少ない労力でより多くのことを達成するのに役立ちます。

#### 従来のコード補完との違い

| 従来のコード補完 | エージェントモード |
|----------------|------------------|
| コードを提案するだけ | ワークスペース全体を理解 |
| 単一ファイルのコンテキスト | プロジェクト全体の構造を評価 |
| 静的な提案 | タスクを動的に処理 |
| 1回の提案で完了 | 独自の出力を反復処理して改善 |

#### エージェントモードでできること

- アプリケーションをゼロから作成
- 複数のファイル間でコードをリファクタリング
- テストを記述して実行
- レガシーコードを最新のフレームワークに移行
- ドキュメントの生成
- 新しいライブラリの統合
- コードベースに関する複雑な質問への回答

### エージェントモードのしくみ

エージェントモードの最も強力な側面の1つは、変更を加える前に**コードベース全体を分析**し、関連するファイルと依存関係を決定できることです。

#### 反復サイクルでの要求処理

静的な提案を提供する従来のAIを利用したコード補完とは異なり、エージェントモードは**反復サイクル**で要求を処理することによって動的に動作します。

タスクを指定すると、以下のステップで処理されます：

1. **分析**: 編集を行う前に、関連するファイルと依存関係を決定
2. **提案と実行**: コードの変更を提案して実行し、プロジェクト構造に合わせて調整
3. **コマンド実行**: コードのコンパイル、依存関係のインストール、テストの実行など、必要に応じてターミナルコマンドを実行
4. **監視と調整**: 出力を監視および調整し、繰り返し反復処理して問題を修復し、精度を向上

この反復的なプロセスにより、Copilotは真に協調的なAIとして機能し、**開発者を完全に制御しながら**、独自の提案を継続的に改善できます。

### GitHub Copilotとの対話方法の比較

GitHub Copilotには、さまざまなレベルのエンゲージメントと自動化をサポートするように設計された、開発ワークフローを支援する複数の方法が用意されています。

| 対話方法 | 説明 | 自動化レベル |
|---------|------|-------------|
| **インライン検索候補** | 入力時にリアルタイムのコード補完を提供（ゴーストテキスト） | 低 |
| **Copilot Chat** | 専用のチャットパネルでコーディング関連の質問に回答 | 中 |
| **Copilot Edits** | 特定の目標に合わせて複数のファイルに変更を適用 | 中〜高 |
| **エージェントモード** | 開発タスクを動的に調整し、複数回反復処理して精度を向上 | 高 |

### エージェントモードの利点

GitHub Copilot エージェントモードを開発ワークフローに統合することで、以下の利点が得られます：

#### 1. 生産性の大幅向上
Copilotが反復的な編集、依存関係の管理、テストなど、コーディングの面倒な側面の多くを処理します。

#### 2. コグニティブ負荷の軽減
開発者は高レベルの設計と問題解決に集中できます。

#### 3. コード品質の確保
エージェントモードは独自の出力を反復処理するため、手動レビューを必要とする前にエラーをキャッチしてソリューションを絞り込みます。

#### 4. プロアクティブなコラボレーション
単なるAIアシスタントではなく、開発者のワークフローに適応し、ソフトウェアを効率的に構築、維持、最適化する能力を強化するインテリジェントなコラボレーターとして機能します。

### エージェントモードを使用する際のベストプラクティス

1. **明確なタスク定義**: 実行したいタスクを具体的に記述する
2. **段階的な確認**: 各ステップでCopilotの提案を確認し、必要に応じて調整
3. **コンテキストの提供**: 関連するファイルを開いておくことで、より適切な提案を得られる
4. **反復を活用**: 最初の結果が完璧でなくても、Copilotが反復処理で改善することを期待

---

## レクチャー8: エージェントモードの自律開発支援機能
**時間目安: 12分**

GitHub Copilot エージェントモードは、複雑なマルチステップタスクを自律的に処理し、そのソリューションを継続的に反復処理することで、従来の AI 支援コーディングを大幅に強化します。この機能を理解することで、開発者はワークフローを合理化し、生産性を最適化し、自動化と人間の監視のバランスを効果的に取ることができます。

### 自律運用

Copilot エージェントモードでは、コーディング要求を個別に分析し、関連するファイルを動的に識別し、適切なターミナルコマンドを決定し、明示的なステップバイステップ命令なしで包括的なソリューションを実装します。

#### 自律運用の例

**タスク**: 新しい REST API エンドポイントを作成する

**エージェントモードが自律的に行うこと**:
- API ルートを作成する (`routes/api.js`)
- メインアプリケーションの更新 (`app.js`)
- 必要な依存関係をインストール (`npm install express`)
- テストケースを生成 (`tests/api.test.js`)

エージェントモードは高度に自律的ですが、開発者は提案された変更ごとに完全な透明性と制御を維持できます。

### 複雑なマルチステップタスクの処理

エージェントモードは、単純なコードの提案に加えて、複雑なタスクを構造化されたシーケンシャルアクションに分割することに優れています。この機能により、手動ワークロードが大幅に削減され、複雑なプロジェクト操作が高速化されます。

#### マルチステップタスクの例

**タスク**: 新しいデータベースを既存のアプリケーションに統合する

**エージェントモードが自律的に実行する処理**:
1. 依存関係の更新 (`npm install mongoose`)
2. データベース接続ロジックを生成 (`database.js`)
3. 環境の構成を変更 (`.env`)
4. 関連するデータモデル定義を作成 (`models/userModel.js`)
5. 関連する自動テストを作成 (`tests/userModel.test.js`)

この体系的なアプローチにより、複雑な開発タスクが合理化されます。

### マルチステップオーケストレーションワークフロー

エージェントモードは、インテリジェントオーケストレーションを通じて複雑な開発プロセスを調整する場合に優れています。各手順で手動による介入を必要とするのではなく、開発サイクルを高速化するシームレスなワークフローでコードのドラフト作成、レビュー、および調整を行うことができます。

#### ドラフト-レビュー-承認ワークフロー

統合されたアプローチを使用して、エージェントモードで機能開発を処理する方法を検討します。

**シナリオ**: アプリケーションへのユーザー認証の追加

| フェーズ | 内容 |
|---------|------|
| **1. ドラフトフェーズ** | 要件を分析し、認証ミドルウェア (`middleware/auth.js`)、ユーザーログインルート (`routes/auth.js`)、パスワードハッシュユーティリティ (`utils/password.js`)、基本的なフロントエンドログインフォーム (`views/login.html`) を生成 |
| **2. レビューフェーズ** | 独自の下書きを評価し、パスワード処理における潜在的なセキュリティの脆弱性を識別、エラー処理パターンの改善を提案、エッジケースに対して追加の検証を推奨、重要な認証機能の単体テストを提案 |
| **3. 受け入れフェーズ** | 開発者は、組み込みのセキュリティのベストプラクティスを使用した完全な機能、包括的なエラー処理と検証、プロジェクト規則に従うすぐにマージできるコード、最初から含まれているドキュメントとテストを確認 |

この調整されたアプローチにより、従来の前後のレビューサイクルが不要になり、運用環境に対応した機能の迅速な配信が可能になります。

#### 自動基礎構築

エージェントモードは、繰り返し行うセットアップタスクを処理する際に役立ち、開発者は定型的な実装ではなく、コアビジネスロジックに集中できます。

**シナリオ**: 新しいマイクロサービスの設定

**エージェントモードが自動的に生成するもの**:
- 標準ディレクトリを含むプロジェクト構造 (`src/`、`tests/`、`config/`)
- パッケージの構成 (`package.json`、`Dockerfile`、`.gitignore`)
- テストフレームワークのセットアップ (`jest.config.js`、サンプルテストファイル)
- CI/CD パイプラインの構成 (`.github/workflows/test.yml`)
- 環境構成テンプレート (`.env.example`、`config/default.js`)
- 基本的な監視およびログ記録のセットアップ (`utils/logger.js`、ヘルスチェックエンドポイント)

**開発者が重点を置くこと**:
- 特定のビジネスロジックとドメインモデルの実装
- 生成された基盤を固有の要件に合わせてカスタマイズ
- 特殊な統合とカスタムワークフローの追加

この分業は、コア機能に対する創造的な制御を維持しながら、標準セットアップを自動化することで開発者の生産性を最大化します。

### 高度な推論機能

より詳細な分析を必要とする複雑なシナリオでは、エージェントモードではプレミアム推論を利用して、より高度なソリューションを提供できます。

| 機能 | 説明 |
|------|------|
| **アーキテクチャの決定分析** | さまざまな実装アプローチ間のトレードオフを評価 |
| **システム間影響評価** | 変更が複数のコンポーネントにどのように影響するかを理解 |
| **パフォーマンス最適化戦略** | ボトルネックを特定し、改善を提案 |
| **セキュリティの脆弱性分析** | 潜在的なセキュリティ問題の修正プログラムを検出して提案 |

> **注意**: Premium 推論（より高度なモデルを使用）では、より豊富なコンテキストと詳細な分析が提供されますが、PRU の消費量が増加します。

### インテリジェントなツールとコンテキスト認識の使用

エージェントモードでは、タスクを効果的に完了するために、プロジェクトのファイル、依存関係、および以前のアクションからのコンテキストが使用されます。既存のプロジェクト構造とコンテキストを分析することで、正確でコンテキストに関連する出力が提供されます。

#### コンテキスト対応のデプロイの例

**シナリオ**: React アプリケーションのデプロイ

**エージェントモードがインテリジェントに行うこと**:
- `package.json` を使用してプロジェクトの種類を認識
- 適切なビルドスクリプトを実行 (`npm run build`)
- 既存のワークフローコンテキストに合わせて配置スクリプトを準備

明確で完全なコンテキストを提供することで、より良く、より正確な結果が得られます。

### 反復的な改善と自己修復

Copilot エージェントモードのコアの強みの1つは、反復的な問題解決能力です。エラーが発生した場合、エージェントモードはソリューションを自律的に検出、修正、再検証し、手動デバッグ作業を大幅に最小限に抑えます。

#### 自己修復の例

**問題**: 生成された単体テストは、構文エラーが原因で最初に失敗する

**エージェントモードが自律的に行うこと**:
1. エラーの原因を検出
2. 修正ソリューションを適用
3. 成功するまでテストを再実行

この反復的なプロセスにより、コードの信頼性が向上し、問題の解決が促進されます。

### ユーザー制御と監視の確保

エージェントモードは、その自律性にもかかわらず、開発者を完全に制御し続けます。エージェントモードによって提案されるすべてのアクションは、いつでもレビュー、調整、または元に戻すことができるため、プロジェクトの標準に合わせて調整できます。

#### 開発者制御の例

**状況**: エージェントモードでは、認証ロジックの広範な変更が提案される

**開発者ができること**:
- pull request の要約された変更を確認
- 特定の改訂や修正を要求
- 必要に応じて変更を簡単に元に戻したり調整

これにより、AI 主導の効率と人間の判断の間の生産性のバランスが確保されます。

### 制限事項と実用的な考慮事項

強力ですが、エージェントモードには制限があります。特殊なドメインロジック、微妙なビジネスルール、または重要なプロジェクトコンテキストが不足している場合は、問題が発生する可能性があります。

#### 制限の例

| 制約 | 考えられる結果 |
|------|--------------|
| 文書化が不十分なカスタムビジネスロジック | 精度が低い、または不完全なソリューション |
| 特殊なドメイン知識の不足 | 手動によるレビューと介入の必要性の増加 |

これらの制限事項を理解することは、開発者が現実的な期待を設定し、結果を最大化するためのより明確なコンテキストを提供するのに役立ちます。

### PRU（Premium Request Units）消費についての注意

エージェントモードの各ハンドオフは、最大 1 PRU を消費します。

| 操作タイプ | PRU消費量 |
|-----------|----------|
| 2段階のドラフト-レビューシーケンス | 2〜3 PRU |
| Premium 推論（高度なモデル使用） | 標準の約2倍（最大4 PRU以上） |

詳細については、[GitHub Copilot の課金と要求](https://docs.github.com/en/copilot/concepts/billing/copilot-requests)を参照してください。

### まとめ

GitHub Copilot エージェントモードは、AI 支援型ソフトウェア開発の大幅な進歩を表し、自律運用とインテリジェントな反復機能と堅牢な監視機能を組み合わせたものです。開発者は、その機能を理解し、制限事項を事前に管理し、組み込みのツールを効果的に使用することで、生産性を大幅に向上させ、高品質のコード標準を維持し、開発ワークフロー全体を加速させることができます。

---

## レクチャー9: MCPとエージェントモードの連携
**時間目安: 10分**

MCP サーバーが GitHub Copilot の機能を拡張する方法を見てきました。次の手順として、それらを Copilot のエージェント モードと組み合わせてみましょう。ここで、Copilot はプロンプトへの応答を超えて移動し、真のコラボレーターとして機能し始め、ワークフローを計画、実行、および絞り込むことができます。

### 学習目標

- Copilot のエージェントモードとは何か、および標準使用との違いを理解する
- MCP サーバーが、Copilot を外部のデータとツールに接続してエージェントモードを強化する方法を学ぶ
- 自動化や手動作業の削減など、MCP とエージェントモードを組み合わせることの主な利点を把握する
- エージェントワークフローで Copilot を効果的にガイドするためのベストプラクティスを適用できるようになる

### Copilot チャットで GitHub MCP サーバーを使用する方法

GitHub MCP サーバーをエージェントモードと組み合わせて使用する手順は以下の通りです：

| ステップ | 操作 |
|---------|------|
| **1** | Visual Studio Code で Copilot チャットを開き、エージェントモードに切り替えて MCP サーバーツールをアクティブにする |
| **2** | 「ツールの選択」をクリックして、使用可能なすべての MCP サーバー機能を表示する |
| **3** | 新しい問題の作成、リポジトリの概要、自然言語プロンプトを使用した作業に関する分析情報の取得を試す |
| **4** | Copilot Chat 内の指示に従って、タスクを効率的に完了する |

### Copilot のエージェント機能と MCP

MCP サーバーが GitHub Copilot を外部のツールとリソースに接続して拡張する方法を見てきました。しかし、これをエージェントモードと組み合わせるとどうなりますか？ここで、Copilot は単なる応答性の高いアシスタントから、独立したコラボレーターのように振る舞うのにシフトします。

#### エージェント機能とは

エージェント機能は、Copilot に以下の能力を提供します：

| 機能 | 説明 |
|------|------|
| **独立した作業** | 一定のガイダンスを必要とせずに複数ステップのワークフローを実行 |
| **意思決定** | コンテキストに基づいて使用するツールまたはアプローチを選択 |
| **適応と改善** | フィードバックに応答し、そのアプローチを調整し、結果を反復処理 |

言い換えると、エージェントモードを使用すると、個々の指示に従うのではなく、より大きな画像を理解するチームメイトを持つような、より自律的な方法でタスクを処理できます。

#### MCP を使用してエージェントモードを強化する方法

エージェントモードはそれ自体が強力です。ただし、MCP サーバーを追加すると、Copilot は即時のコーディング環境を超えて到達できるようになります。

MCP を通じて、Copilot は次のことができます：

| 機能 | 説明 |
|------|------|
| **外部データへのアクセス** | 外部データ、API、またはエンタープライズツールに直接アクセス |
| **コンテキストの維持** | アプリケーションを切り替える必要なく、複数のプラットフォーム間でコンテキストを維持 |
| **エージェントループの完了** | プロセスを最初から再起動することなく、情報を動的にシークし、結果を分析し、情報に基づく次のステップを実行 |

つまり、Copilot は単なるプロンプトに反応しているだけではありません。代わりに、必要な結果が得られるまで、探索、適応、調整というサイクルで動作します。

### MCP とエージェントモードを組み合わせる利点

これら2つの機能を組み合わせると、以下の主な利点が得られます：

| 利点 | 説明 |
|------|------|
| **拡張コンテキスト** | Copilot は、コードエディターだけでなく、複数のシステムからの情報を描画できる |
| **手動作業の削減** | 問題のオープン、ワークフローの管理、チェックの実行などの日常的な作業は、価値の高い決定に集中しながら自動化できる |
| **シームレスな統合** | Copilot は、カスタムコネクタや一定の切り替えを必要とせずに、ツールとプラットフォームにまたがるタスクを実行できる |

### 成功のためのベストプラクティス

MCP とエージェントモードを最大限に活用するには、以下のベストプラクティスを試してください：

#### 1. 目標を明確にする

Copilot が達成する内容と、最終的な出力がどのようになるかを定義します。

**良い例**:
```
このリポジトリの未解決のIssueを優先度順にリストアップし、それぞれに対する解決策の概要を提案してください。
```

**悪い例**:
```
Issueを見て
```

#### 2. コンテキストを提供する

プロジェクトまたはワークフローに関する背景の詳細を共有します。これには、リンク、参照、または前の手順が含まれる場合があります。

**例**:
```
このプロジェクトはReact + TypeScriptで構築されており、APIはExpressで実装されています。認証にはJWTを使用しています。この情報を踏まえて、新しいユーザー登録機能を実装してください。
```

#### 3. 境界を設定する

Copilot が計画を中止する（まだ変更を加えない）場合は、次の状態にします。アクティブな MCP ツールを制限することもできます。

**例**:
```
まず実装計画を作成してください。コードの変更は私が確認してから行ってください。
```

#### 4. 確認を求める

大きな変更を加える前に、Copilot に計画を要約して、承認または調整できるようにします。

**例**:
```
変更を適用する前に、影響を受けるファイルと変更内容の概要を教えてください。
```

#### 5. プロンプトファイルまたは指示を使用する

特定の MCP サーバーで動作する方法について Copilot をガイドするカスタムプロンプトファイルを作成します。これにより、動作の一貫性が保たれ、ワークフローに合わせて調整されます。

**プロンプトファイルの例**（`.github/copilot-instructions.md`）:
```markdown
# Copilot 指示

## プロジェクト概要
- このプロジェクトはTypeScriptで構築されたWebアプリケーションです
- テストフレームワークにはJestを使用しています

## コーディング規約
- 変数名はcamelCaseを使用
- コンポーネントはPascalCaseで命名
- すべての関数にはJSDocコメントを追加

## MCP使用時の注意
- Issueを作成する前に既存のIssueを確認
- PRを作成する際は必ずテストを実行
```

### 従来のCopilot使用とMCP+エージェントモードの比較

| 側面 | 従来のCopilot | MCP + エージェントモード |
|------|--------------|------------------------|
| **スコープ** | 単一ファイルまたは選択されたコード | プロジェクト全体 + 外部システム |
| **対話方法** | プロンプト → 応答 | タスク → 計画 → 実行 → 反復 |
| **外部ツール** | 限定的 | API、データベース、サービスに直接アクセス |
| **自律性** | 低（人間の入力が必要） | 高（独立して複数ステップを実行） |
| **コンテキスト** | 開いているファイルのみ | 複数プラットフォーム間で維持 |

### 実践的なユースケース

#### ユースケース1: 問題トリアージの自動化

```
@workspace MCPツールを使用して、このリポジトリの未解決のIssueを分析し、優先度（高/中/低）でラベル付けしてください。各Issueの影響範囲も評価してください。
```

#### ユースケース2: コードレビューとPR作成

```
@workspace 現在のブランチの変更をレビューし、問題がなければPRを作成してください。PRの説明には変更の概要と影響を含めてください。
```

#### ユースケース3: プロジェクト状態の分析

```
@workspace MCPを使用してこのリポジトリの全体的な健全性を分析してください。未解決のIssue数、最近のコミット活動、テストカバレッジの状況を報告してください。
```

### まとめ

- **エージェントモード**は、Copilotを単なる提案ツールから自律的なコラボレーターに変える
- **MCP**は、外部ツールとデータへのアクセスを提供し、エージェントモードの機能を拡張する
- **組み合わせ**により、拡張コンテキスト、手動作業の削減、シームレスな統合が実現する
- **ベストプラクティス**を適用することで、より効果的なAI支援開発ワークフローを構築できる

### 参照

- [Copilot チャットでの GitHub MCP サーバーの使用 - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/mcp-server/4-use-github-copilot-chat)

---

## レクチャー10: GitHub.comでのCopilot Chat活用
**時間目安: 12分**

### 学習目標
- GitHub.com上でGitHub Copilotにアクセスする方法を理解する
- GitHub.comで利用可能なCopilotのエージェントタスクを把握する
- リポジトリの探索とドキュメント機能を活用できるようになる
- Issue管理とGitHub Actionsエラー説明機能を理解する

### GitHub.comでのCopilotへのアクセス

GitHub Copilotはローカル開発環境を超えて、GitHub.comに直接AI支援を提供します。GitHub WebインターフェイスでリポジトリやIssue、Pull Request、ディスカッションを操作する際に、Copilotの機能を利用してワークフローを効率化できます。

#### アクセス可能な領域

| 領域 | 機能 |
|------|------|
| **リポジトリページ** | コード、ドキュメント、プロジェクト構造の説明を取得 |
| **IssueとPull Request** | 要約の生成、解決策の提案、返答の下書き |
| **ディスカッション** | 回答の考案と技術的な分析情報の提供を支援 |
| **コードレビュー** | 変更を分析し、改善点を提案 |

### GitHub.comでのエージェントタスク

GitHub.comでCopilotを使用すると、さまざまなエージェント駆動型タスクを実行できます。これらのタスクは、ユーザーが他の作業に集中している間、バックグラウンドで実行できます。

**主なエージェントタスク:**
- リポジトリの探索
- Pull Requestの支援
- Issueの管理
- コードレビュー

### リポジトリの探索とドキュメント

#### コードの説明
複雑なコードセクション、関数、ファイル全体についての説明をCopilotに依頼できます。

**質問例:**
```
このリポジトリとその主要なコンポーネントの主な機能について説明してください
```

#### プロジェクトの概要
リポジトリの目的、アーキテクチャ、主要なコンポーネントについてAI生成の要約を取得できます。

#### ドキュメントの生成
READMEファイル、APIドキュメント、およびコードのコメントを作成または改善できます。

| 機能 | 説明 | 活用場面 |
|------|------|---------|
| **コードの説明** | 複雑なコードの解説 | 新規参加メンバーのオンボーディング |
| **プロジェクトの概要** | リポジトリ全体の要約 | プロジェクト理解の迅速化 |
| **ドキュメントの生成** | README、APIドキュメント作成 | ドキュメント整備の効率化 |

### 問題（Issue）の管理

GitHub Copilotは、Issueの分析と管理を支援します。

#### 主な機能

| 機能 | 説明 |
|------|------|
| **問題の分析** | 複雑なIssueを実践可能なタスクに分割 |
| **ソリューションのブレーンストーミング** | 報告された問題を解決するための潜在的なアプローチを生成 |
| **再現手順** | バグや問題を再現するための明確な手順の作成を支援 |

**質問例:**
```
このIssueを分析し、実装のアプローチとともに潜在的な解決策を提案してください
```

### GitHub Actionsでのエラー説明

GitHub Copilotは、GitHub Actionsワークフローで発生するエラーの説明と解決に役立ちます。失敗したワークフローの実行を分析し、何に問題があったのかとその修正方法に関する分析情報を提供します。

#### Copilotがアクションのエラーを説明する方法

| 機能 | 説明 |
|------|------|
| **エラー分析** | ログファイルを調べ、エラーの根本原因を特定 |
| **解決策の提案** | ワークフローの問題を解決するための具体的な推奨事項を提供 |
| **ベストプラクティス** | ワークフローの信頼性とパフォーマンスの向上に関するガイダンスを提供 |
| **コンテキスト認識** | さまざまなワークフローステップと依存関係の関係を把握 |

### まとめ

- GitHub.comでCopilotは複数の領域（リポジトリ、Issue、PR、ディスカッション）で利用可能
- エージェントタスクはバックグラウンドで実行可能
- リポジトリの探索、Issue管理、GitHub Actionsエラー説明など幅広い機能を提供

---

## レクチャー11: カスタムモデルとエージェント設定（Enterprise）
**時間目安: 10分**

### 学習目標
- BYOK（Bring Your Own Key）機能を理解する
- 利用可能なモデルプロバイダーを把握する
- カスタムエージェントとカスタム指示の違いを理解する

### BYOK（Bring Your Own Key）機能

BYOKは、組織や企業が**独自のLLMプロバイダーAPIキー**を使用してCopilotをカスタマイズできる機能です。

#### 対応プロバイダー

| プロバイダー | 特徴 |
|-------------|------|
| **OpenAI** | GPTシリーズ（GPT-4、GPT-4o等） |
| **Anthropic** | Claudeシリーズ |
| **Google** | Geminiシリーズ |
| **Azure OpenAI** | Azureでホストされたモデル |
| **xAI** | 最新のAIモデル |

### BYOKのメリット

| メリット | 説明 |
|----------|------|
| **モデル選択の拡大** | 標準オプション以外のモデルを使用可能 |
| **要件への適合** | インフラ、セキュリティ、パフォーマンス要件に合致 |
| **使用量の管理** | プロバイダーとの直接的なAPI使用量の制御と監視 |
| **柔軟な切り替え** | 組み込みモデルとカスタムモデルの簡単な切り替え |

### カスタムモデルの設定手順

1. AI Controlsタブにアクセス（Enterpriseまたは組織設定）
2. Copilotセクションで「Configure allowed models」を選択
3. APIキーを入力
4. 使用するモデルを選択
5. 設定を保存

### 注意事項

| 項目 | 内容 |
|------|------|
| **対象範囲** | Copilot Chat体験のみ（コード補完は対象外） |
| **責任あるAI** | カスタムモデル使用時はフィルタリングがバイパスされる可能性あり |
| **利用制限** | Business/Enterpriseユーザーは管理者の有効化が必要 |

### カスタムエージェント

`agent_profile`を定義したMarkdownファイルで独自のエージェントを作成できます。

| 設定項目 | 説明 |
|----------|------|
| **名前・説明** | エージェントの識別情報 |
| **利用可能ツール** | エージェントが使用できるツール |
| **AIモデル** | 使用するモデルの指定 |

### カスタム指示の階層

カスタム指示は複数のレベルで設定でき、Copilotの応答をカスタマイズします。

| レベル | 適用範囲 | 設定者 |
|--------|----------|--------|
| **個人** | ユーザー個人の設定 | 各ユーザー |
| **リポジトリ** | 特定リポジトリ内 | リポジトリ管理者 |
| **組織** | 組織全体（Enterprise限定） | 組織管理者 |

### まとめ

- BYOKで独自のLLMプロバイダーを使用可能
- OpenAI、Anthropic、Google、Azure等に対応
- カスタムエージェントで専用のAIアシスタントを作成
- カスタム指示は個人・リポジトリ・組織レベルで設定可能

---

## レクチャー12: 【確認テスト】Copilot Chat & エージェントモード
**時間目安: 10分**

### 小テスト: GitHub Copilotの高度な機能

**Q1. GitHub Copilotのゴーストテキスト（提案）を受け入れるために使用するキーは？**
- A) Enter キー
- B) Tab キー
- C) Space キー
- D) Shift キー

<details>
<summary>解答</summary>
B) Tab キー - ゴーストテキストは Tab キーを押すことで受け入れることができます。
</details>

**Q2. Windowsでインラインチャットにアクセスするためのショートカットは？**
- A) Ctrl + c
- B) Ctrl + v
- C) Ctrl + i
- D) Ctrl + p

<details>
<summary>解答</summary>
C) Ctrl + i - Windowsでは Ctrl + i を使用してインラインチャットにアクセスします。
</details>

**Q3. Macでインラインチャットにアクセスするためのショートカットは？**
- A) Command + c
- B) Command + v
- C) Command + i
- D) Command + p

<details>
<summary>解答</summary>
C) Command + i - Macでは Command + i を使用してインラインチャットにアクセスします。
</details>

**Q4. Visual Studio Codeでチャットインターフェイスを開くにはどこをクリックしますか？**
- A) 右側のサイドバーのファイルアイコン
- B) 左側のサイドバーのチャットアイコン
- C) メニューバーの「表示」
- D) ステータスバーのCopilotアイコン

<details>
<summary>解答</summary>
B) 左側のサイドバーのチャットアイコン - 左側のサイドバーにあるチャットアイコンをクリックして、専用のペインでチャットインターフェイスを開きます。
</details>

**Q5. スラッシュコマンドを使用する主な利点は何ですか？**
- A) コードの実行速度が向上する
- B) より長いプロンプトを記述することなく、より適切な応答を取得できる
- C) ファイルを自動的に保存できる
- D) コードのコンパイルが高速化される

<details>
<summary>解答</summary>
B) より長いプロンプトを記述することなく、より適切な応答を取得できる - 特定のスラッシュコマンドを使用した質問の作成は、より長いプロンプトを記述することなく、より適切な応答を取得するために推奨される方法です。
</details>

**Q6. テストの記述を支援するために使用するスラッシュコマンドは？**
- A) /code
- B) /help
- C) /tests
- D) /run

<details>
<summary>解答</summary>
C) /tests - /tests スラッシュコマンドはテストの記述に役立ちます。
</details>

**Q7. ドキュメントの記述を支援するために使用するスラッシュコマンドは？**
- A) /docs
- B) /write
- C) /readme
- D) /comment

<details>
<summary>解答</summary>
A) /docs - /docs コマンドはドキュメントの記述を目的としています。
</details>

**Q8. @workspace エージェントの特徴として正しいものは？**
- A) ターミナルコマンドのみに対応する
- B) 現在のファイルのみを認識する
- C) ワークスペース全体を認識している
- D) 外部APIとの通信を行う

<details>
<summary>解答</summary>
C) ワークスペース全体を認識している - @workspace エージェントはワークスペース全体を認識しているため、プロジェクト全体に関する疑問について質問できます。
</details>

**Q9. @terminal エージェントの主な用途は何ですか？**
- A) ファイルの編集を支援する
- B) ターミナルと対話するのに役立つ
- C) コードのリファクタリングを行う
- D) テストを実行する

<details>
<summary>解答</summary>
B) ターミナルと対話するのに役立つ - @terminal エージェントは、GitHub Copilot とチャットしてターミナルと対話するのに役立ちます。
</details>

**Q10. チャットエージェントを使用するための正しい構文は？**
- A) エージェント名の後に質問を記述する（例：workspace@ how can I...）
- B) 質問の前にエージェント名を付ける（例：@workspace how can I...）
- C) 質問の最後にエージェント名を記述する（例：how can I... @workspace）
- D) エージェント名をカッコで囲む（例：(workspace) how can I...）

<details>
<summary>解答</summary>
B) 質問の前にエージェント名を付ける（例：@workspace how can I...） - エージェントを使用するには、質問の前にエージェントを付けます。
</details>

---

### 小テスト: GitHub Copilotの応用手法

**Q1. Pythonコードにバグがある場合、インラインチャットでコードを修正するために使用するスラッシュコマンドは？**
- A) /doc
- B) /fix
- C) /explain
- D) /generate

<details>
<summary>解答</summary>
B) /fix - /fixスラッシュコマンドを使用すると、GitHub Copilotにコードの修正を依頼できます。
</details>

**Q2. 選択したコードのランタイムを分析して改善するために使用するスラッシュコマンドは？**
- A) /tests
- B) /generate
- C) /optimize
- D) /help

<details>
<summary>解答</summary>
C) /optimize - /optimizeスラッシュコマンドは選択したコードのランタイムを分析して改善します。
</details>

**Q3. スラッシュコマンドを使用する主な利点として正しいものは？**
- A) コードの実行速度が向上する
- B) 長いプロンプトを記述せずに、より適切な応答を取得できる
- C) 自動的にファイルが保存される
- D) コンパイルエラーが自動修正される

<details>
<summary>解答</summary>
B) 長いプロンプトを記述せずに、より適切な応答を取得できる - スラッシュコマンドにより、GitHub Copilotとの対話が簡単になり、事前に作成されたプロンプトを暗黙的に使用できます。
</details>

**Q4. プロジェクトをパッケージ化するDockerfileの作成を支援してもらいたい場合、使用すべきエージェントは？**
- A) @terminal
- B) @file
- C) @workspace
- D) @directory

<details>
<summary>解答</summary>
C) @workspace - @workspaceエージェントはワークスペース全体を認識しているため、プロジェクト全体に関する質問（Dockerfileの作成など）に適しています。
</details>

**Q5. 特定のファイル（例：main.py）の関数をリファクタリングしたい場合、最適なエージェントは？**
- A) @workspace
- B) @terminal
- C) @file
- D) @directory

<details>
<summary>解答</summary>
C) @file - @fileエージェントは特定のファイルの内容に焦点を当てるため、特定ファイルのリファクタリングに適しています。
</details>

**Q6. utilsディレクトリ内のスクリプトを最適化したい場合、使用すべきエージェントは？**
- A) @workspace
- B) @terminal
- C) @file
- D) @directory

<details>
<summary>解答</summary>
D) @directory - @directoryエージェントは特定のディレクトリの内容を考慮するため、ディレクトリ内のスクリプト最適化に適しています。
</details>

**Q7. ターミナルに表示されているエラーメッセージの修正方法を知りたい場合、使用すべきエージェントは？**
- A) @workspace
- B) @terminal
- C) @file
- D) @directory

<details>
<summary>解答</summary>
B) @terminal - @terminalエージェントはターミナル出力に基づいて提案を提供するため、ターミナルエラーの修正に適しています。
</details>

**Q8. @workspaceエージェントを使用しない場合、GitHub Copilotはどのようなコンテキストを使用しますか？**
- A) インターネット上の公開コードのみ
- B) テキストエディターで開いているファイル
- C) リポジトリ全体のコード
- D) 過去の会話履歴のみ

<details>
<summary>解答</summary>
B) テキストエディターで開いているファイル - @workspaceで具体的に指定しなくても、GitHub Copilotはテキストエディターで開いているファイルを追加のコンテキストとして使用します。
</details>

**Q9. 提案が期待通りでない場合の対処法として正しいものは？**
- A) GitHub Copilotを再インストールする
- B) プロンプトの文言を変更して、より具体的に指示する
- C) 別のエディターに切り替える
- D) ネットワーク接続を確認する

<details>
<summary>解答</summary>
B) プロンプトの文言を変更して、より具体的に指示する - 提案が探しているものと一致しない場合は、プロンプトの文言を変更してより具体的に指示できます。
</details>

**Q10. インラインチャットとスラッシュコマンドを組み合わせることの利点は？**
- A) コードの自動デプロイが可能になる
- B) ユーザーと作業中のコードにとって最適な方法を選択できる
- C) コードのバージョン管理が自動化される
- D) テストが自動実行される

<details>
<summary>解答</summary>
B) ユーザーと作業中のコードにとって最適な方法を選択できる - スラッシュコマンドなどの機能とインラインチャットを組み合わせることで、ユーザーと作業中のコードにとって最適な方法を選択できます。
</details>

---

### 小テスト: Microsoft Learn 認定試験形式

**Q1. GitHub Copilot のゴースト テキストとは何ですか?**
- A) GitHub Copilot のゴースト テキストは、入力時にテキスト エディターに表示される候補です。
- B) GitHub Copilot のゴースト テキストは、入力時に提案を提供するために使用されるオプションです。
- C) GitHub Copilot のゴースト テキストには、コードまたはドキュメント内でのプロンプトと自然言語の質問の使用が関連します。

<details>
<summary>解答</summary>
A) GitHub Copilot のゴースト テキストは、入力時にテキスト エディターに表示される候補です。
</details>

**Q2. GitHub Copilot のインライン チャットにアクセスするにはどうすればよいですか?**
- A) Visual Studio Code の左側のサイドバーにあるチャット アイコンをクリックして、インライン チャットにアクセスします。
- B) Windows では Ctrl + I、Mac では Command + I を使用してインライン チャットを開きます。
- C) Windows の Alt + I または Mac の Option + I を使用してインライン チャットにアクセスします。

<details>
<summary>解答</summary>
B) Windows では Ctrl + I、Mac では Command + I を使用してインライン チャットを開きます。
</details>

**Q3. GitHub Copilot で使用されるスラッシュ コマンドとは何ですか?**
- A) スラッシュ コマンドは、ベスト プラクティスに従ってコードベースを書式設定するために使用されます。
- B) スラッシュ コマンドは、プロジェクト内のコードをデバッグし、セキュリティの脆弱性を検出するために使用されます。
- C) スラッシュ コマンドは、チャットまたはインライン ウィンドウ内の一般的な開発タスクをすばやく解決するためのショートカットです。

<details>
<summary>解答</summary>
C) スラッシュ コマンドは、チャットまたはインライン ウィンドウ内の一般的な開発タスクをすばやく解決するためのショートカットです。
</details>

**Q4. GitHub Copilot と対話するときに、"@terminal" や "@workspace" などのエージェントを使用する利点は何ですか?**
- A) Visual Studio Code のエージェントは、特定のコンテキスト内で質問するのに役立ちます。これにより、GitHub Copilot からのより正確で関連性の高い回答を得ることができます。
- B) エージェントは、読みやすさを向上させるために、Visual Studio Code 内のベスト プラクティスに基づいて一貫したコード形式を適用するのに役立ちます。
- C) エージェントは、Visual Studio Code プロジェクト内の脆弱性と侵入を検出するための追加のセキュリティ機能を提供します。

<details>
<summary>解答</summary>
A) Visual Studio Code のエージェントは、特定のコンテキスト内で質問するのに役立ちます。これにより、GitHub Copilot からのより正確で関連性の高い回答を得ることができます。
</details>

**Q5. GitHub Copilot でコードの問題を修正するためにインライン チャットでスラッシュ コマンドが含まれる暗黙的なプロンプトを使用する利点は何ですか?**
- A) 暗黙的なプロンプトは、読みやすさを向上させるために、Visual Studio Code プロジェクト内のベスト プラクティスに基づいて一貫した名前付け規則と構文を適用するのに役立ちます。
- B) 暗黙的なプロンプトは、より長いプロンプトを書かずに GitHub Copilot からより良い応答を得るのに役立ち、コードの問題への対処と修正が容易になります。
- C) 暗黙的なプロンプトは、セキュリティの脆弱性と潜在的な悪意のあるアクティビティを Visual Studio Code プロジェクト内で検出し、安全性を高めるのに役立ちます。

<details>
<summary>解答</summary>
B) 暗黙的なプロンプトは、より長いプロンプトを書かずに GitHub Copilot からより良い応答を得るのに役立ち、コードの問題への対処と修正が容易になります。
</details>

---

### 追加小テスト: 認定試験対策

**Q6. 選択したコードの単体テストを生成するために使用される GitHub Copilot Chat 内のスラッシュ コマンドはどれですか?**
- A) /generate
- B) /test
- C) /tests
- D) /unittest

<details>
<summary>解答</summary>
C) /tests

`/tests` スラッシュコマンドは、選択したコードに対する単体テストの生成を支援します。
</details>

---

**Q7. GitHub Copilot Chat 内の @workspace エージェントの目的は何ですか?**
- A) 現在のファイルのみにフォーカスすること
- B) 質問のコンテキストをプロジェクト全体に拡張すること
- C) ターミナル コマンドを実行すること
- D) Visual Studio Code の設定を変更すること

<details>
<summary>解答</summary>
B) 質問のコンテキストをプロジェクト全体に拡張すること

`@workspace` エージェントを使用すると、Copilot にするあらゆる質問のコンテキストをプロジェクト全体に拡張できます。これにより、プロジェクト全体の情報を使用して、より適切なコード生成やコードベース全体に関する回答を取得できます。
</details>

---

### 小テスト: GitHub Copilot エージェントモード

**Q1. GitHub Copilot エージェントモードの主な特徴として正しいものは？**
- A) 単一ファイルのみを分析する
- B) ワークスペース全体を理解し、タスクを動的に処理する
- C) コード補完のみを提供する
- D) 手動でのコマンド実行のみをサポートする

<details>
<summary>解答</summary>
B) ワークスペース全体を理解し、タスクを動的に処理する

エージェントモードは自律的なピアプログラマとして機能し、ワークスペース全体を理解してタスクを動的に処理します。単なるコード補完ではなく、プロジェクト全体の構造を評価し、関連するファイルと依存関係を決定できます。
</details>

---

**Q2. エージェントモードが要求を処理する際の動作として正しいものは？**
- A) 静的な提案を1回だけ提供する
- B) 反復サイクルで要求を処理し、出力を監視・調整する
- C) ユーザーの承認なしに自動的にコードをコミットする
- D) インターネットから直接コードをダウンロードする

<details>
<summary>解答</summary>
B) 反復サイクルで要求を処理し、出力を監視・調整する

エージェントモードは反復サイクルで要求を処理し、出力を監視および調整して繰り返し改善します。これには、関連ファイルの分析、コード変更の提案と実行、ターミナルコマンドの実行、そして結果の監視と調整が含まれます。
</details>

---

**Q3. GitHub Copilotの対話方法の中で、最も自律的なAIコラボレーターとして機能するものは？**
- A) インライン検索候補（ゴーストテキスト）
- B) Copilot Chat
- C) Copilot Edits
- D) エージェントモード

<details>
<summary>解答</summary>
D) エージェントモード

エージェントモードは開発タスクを動的に調整し、複数回反復処理して精度を向上させる、最も自律的なAIコラボレーターです。インライン検索候補は基本的なコード補完、Copilot Chatは対話的な質問応答、Copilot Editsは複数ファイルへの変更適用を行いますが、エージェントモードはこれらを超えて自律的にタスクを処理します。
</details>

---

**Q4. エージェントモードの利点として正しくないものは？**
- A) 生産性の大幅向上
- B) コグニティブ負荷の軽減
- C) 開発者の介入なしに完全自動でコードを本番環境にデプロイする
- D) コード品質の確保

<details>
<summary>解答</summary>
C) 開発者の介入なしに完全自動でコードを本番環境にデプロイする

エージェントモードは生産性の向上、コグニティブ負荷の軽減、コード品質の確保に役立ちますが、開発者を完全に制御しながら機能します。完全自動で本番環境にデプロイする機能はなく、開発者が各ステップで確認と承認を行うことが前提となっています。
</details>

---

**Q5. エージェントモードが変更を加える前に行うことは何ですか？**
- A) 自動的にバックアップを作成する
- B) コードベース全体を分析し、関連するファイルと依存関係を決定する
- C) ユーザーにメールで通知を送信する
- D) 外部のコードレビューサービスに接続する

<details>
<summary>解答</summary>
B) コードベース全体を分析し、関連するファイルと依存関係を決定する

エージェントモードの最も強力な側面の1つは、変更を加える前にコードベース全体を分析し、関連するファイルと依存関係を決定できることです。これにより、プロジェクト全体の視点を必要とするタスク（複数ファイル間でのリファクタリングなど）を適切に処理できます。
</details>

---

### 小テスト: エージェントモードの自律開発支援機能

**Q1. エージェントモードの自律運用において、REST APIエンドポイント作成タスクで自動的に行われることは？**
- A) コードのみを生成し、依存関係のインストールは手動で行う必要がある
- B) APIルート作成、アプリケーション更新、依存関係インストール、テストケース生成を自動的に行う
- C) 外部サービスへのデプロイまで自動的に完了する
- D) コードレビューを外部チームに自動送信する

<details>
<summary>解答</summary>
B) APIルート作成、アプリケーション更新、依存関係インストール、テストケース生成を自動的に行う

エージェントモードは自律的に、APIルート（routes/api.js）の作成、メインアプリケーション（app.js）の更新、必要な依存関係（npm install express）のインストール、テストケース（tests/api.test.js）の生成を行います。
</details>

---

**Q2. エージェントモードのドラフト-レビュー-承認ワークフローにおける「レビューフェーズ」で行われることは？**
- A) 開発者が手動でコードをレビューする
- B) エージェントモードが独自の下書きを評価し、セキュリティの脆弱性やエラー処理パターンの改善を提案する
- C) 外部のコードレビューツールにコードを送信する
- D) 本番環境へのデプロイ準備を行う

<details>
<summary>解答</summary>
B) エージェントモードが独自の下書きを評価し、セキュリティの脆弱性やエラー処理パターンの改善を提案する

レビューフェーズでは、エージェントモードが独自の下書きを評価し、パスワード処理における潜在的なセキュリティの脆弱性を識別、エラー処理パターンの改善を提案、エッジケースに対して追加の検証を推奨、重要な機能の単体テストを提案します。
</details>

---

**Q3. 新しいマイクロサービスのセットアップにおいて、エージェントモードが自動的に生成するものとして正しくないものは？**
- A) プロジェクト構造（src/、tests/、config/）
- B) CI/CDパイプラインの構成（.github/workflows/test.yml）
- C) 特定のビジネスロジックとドメインモデルの実装
- D) 環境構成テンプレート（.env.example）

<details>
<summary>解答</summary>
C) 特定のビジネスロジックとドメインモデルの実装

エージェントモードは標準的なプロジェクト構造、パッケージの構成、テストフレームワーク、CI/CDパイプライン、環境構成テンプレートなどを自動生成しますが、特定のビジネスロジックとドメインモデルの実装は開発者が行うべき作業です。これにより、開発者は定型的な実装ではなく、コアビジネスロジックに集中できます。
</details>

---

**Q4. エージェントモードの高度な推論機能に含まれないものは？**
- A) アーキテクチャの決定分析
- B) システム間影響評価
- C) 自動的な本番環境へのデプロイ
- D) セキュリティの脆弱性分析

<details>
<summary>解答</summary>
C) 自動的な本番環境へのデプロイ

高度な推論機能には、アーキテクチャの決定分析、システム間影響評価、パフォーマンス最適化戦略、セキュリティの脆弱性分析が含まれます。自動的な本番環境へのデプロイは高度な推論機能には含まれず、開発者の監視と承認が必要です。
</details>

---

**Q5. エージェントモードの「反復的な改善と自己修復」機能の説明として正しいものは？**
- A) エラーが発生した場合、開発者に通知して手動修正を待つ
- B) エラーが発生した場合、ソリューションを自律的に検出、修正、再検証する
- C) エラーが発生した場合、自動的に以前のバージョンにロールバックする
- D) エラーが発生した場合、外部のデバッグサービスに接続する

<details>
<summary>解答</summary>
B) エラーが発生した場合、ソリューションを自律的に検出、修正、再検証する

エージェントモードの反復的な問題解決能力により、エラーが発生した場合、エージェントモードはソリューションを自律的に検出、修正、再検証し、手動デバッグ作業を大幅に最小限に抑えます。
</details>

---

### 追加小テスト: エージェントモード認定試験対策（Microsoft Learn）

**Q1. GitHub Copilot エージェント モードは、従来の AI 支援コーディング ツールとどのような重要な点で異なりますか?**
- A) コードの生成には、ユーザーが指定したステップ バイ ステップの手順に排他的に依存します。
- B) プロジェクト全体を動的に分析し、複数ステップのタスクを自律的に実行し、出力を繰り返し調整します。
- C) これは主に、1 つの開いているファイルの即時コンテキストに基づいてコード スニペットを提案します。
- D) リアルタイムのインライン候補が提供されますが、コードを自律的にリファクタリングしたり実行したりすることはできません。

<details>
<summary>解答</summary>
B) プロジェクト全体を動的に分析し、複数ステップのタスクを自律的に実行し、出力を繰り返し調整します。

エージェントモードは従来のコード補完とは異なり、ワークスペース全体を理解し、タスクを動的に処理します。単一ファイルのコンテキストではなくプロジェクト全体の構造を評価し、独自の出力を反復処理して改善できます。
</details>

---

**Q2. 生成されたソリューションを GitHub Copilot エージェント モードで繰り返し改善する方法を説明する方法はどれですか?**
- A) 初期ソリューションを提案し、テストを実行してデバッグするには手動の開発者の介入が必要です。
- B) テストを通じて問題を自動的に識別し、自律的にエラーを修正し、サイクルを繰り返してソリューションを絞り込みます。
- C) タスクごとに 1 回だけコードを生成し、手動レビューに依存して改善を行います。
- D) すべてのコード改善を外部テスト フレームワークに完全に委任し、自律的にエラーに対処することはありません。

<details>
<summary>解答</summary>
B) テストを通じて問題を自動的に識別し、自律的にエラーを修正し、サイクルを繰り返してソリューションを絞り込みます。

エージェントモードは反復サイクルで要求を処理し、出力を監視および調整して繰り返し改善します。エラーが発生した場合、ソリューションを自律的に検出、修正、再検証し、手動デバッグ作業を最小限に抑えます。
</details>

---

**Q3. 従来の JavaScript アプリケーションを最新のフレームワークに移行するように GitHub Copilot エージェント モードに指示します。エージェント モードでは自律的に実行される可能性が高いアクションは何ですか?**
- A) 依存関係やプロジェクト構造を変更せずに、個々のファイルに対してのみインライン コード補完を提供します。
- B) テストを実行して、関連するファイルの識別、依存関係の更新、複数のファイル間での既存のコードのリファクタリング、変更の繰り返し検証を行います。
- C) 移行が行われる必要がある理由を説明する新しいドキュメントを生成しますが、実際のコード実装は開発者に任せます。
- D) テストを自律的に実行することなく、コード変更の各ステップで手動入力を開発者に求めます。

<details>
<summary>解答</summary>
B) テストを実行して、関連するファイルの識別、依存関係の更新、複数のファイル間での既存のコードのリファクタリング、変更の繰り返し検証を行います。

エージェントモードは複雑なマルチステップタスクを自律的に処理できます。移行タスクでは、関連ファイルを識別し、依存関係を更新し、複数ファイル間でコードをリファクタリングし、テストを実行して変更を検証するという一連の処理を自律的に行います。
</details>

---

**Q4. GitHub Copilot エージェント モードを使用する場合のプロジェクト ドキュメント ファイル (README.md など) の役割は何ですか?**
- A) 開発者向けの参照ドキュメントとしてのみ機能し、エージェント モードの動作には影響しません。
- B) これらは、エージェント モードがプロジェクトの意図した動作を理解するのに役立ち、自律的にタスクを実行する方法に影響を与えます。
- C) エージェント モードのコード ファイルへのアクセスを制限し、不要な変更を防ぎます。
- D) エージェント モードでは、ドキュメント ファイルは完全に無視され、ファイル構造とソース コードのみに依存します。

<details>
<summary>解答</summary>
B) これらは、エージェント モードがプロジェクトの意図した動作を理解するのに役立ち、自律的にタスクを実行する方法に影響を与えます。

エージェントモードはプロジェクトのファイル、依存関係、および以前のアクションからのコンテキストを使用してタスクを効果的に完了します。READMEなどのドキュメントファイルはプロジェクトの意図した動作を理解するための重要なコンテキストを提供し、より正確でコンテキストに関連する出力を生成するのに役立ちます。
</details>

---

**Q5. GitHub Copilot エージェント モードを使用する場合、開発者が考慮すべき重要な制限事項は何ですか?**
- A) すべてのコード生成後に手動構成を有効にする必要があります。
- B) これは、明確なパターンを欠く高度に特殊なドメイン知識や微妙なビジネス ロジックに苦労する可能性があります。
- C) コード スニペットの生成のみをサポートし、テストを自律的にリファクタリングまたは実行することはできません。
- D) 明示的な開発者が提供するコンテキストのみに依存して、プロジェクトの構造と依存関係を分析することはできません。

<details>
<summary>解答</summary>
B) これは、明確なパターンを欠く高度に特殊なドメイン知識や微妙なビジネス ロジックに苦労する可能性があります。

エージェントモードは強力ですが、特殊なドメインロジック、微妙なビジネスルール、または重要なプロジェクトコンテキストが不足している場合は問題が発生する可能性があります。文書化が不十分なカスタムビジネスロジックでは、精度が低いまたは不完全なソリューションになることがあり、手動によるレビューと介入の必要性が増加します。
</details>

---

### 小テスト: MCPとエージェントモードの連携

**Q1. エージェントモードにMCPサーバーを追加することで、Copilotが新たにできるようになることとして正しくないものは？**
- A) 外部データ、API、またはエンタープライズツールに直接アクセスする
- B) アプリケーションを切り替える必要なく、複数のプラットフォーム間でコンテキストを維持する
- C) 完全に自動でコードを本番環境にデプロイする
- D) プロセスを最初から再起動することなく、情報を動的にシークし、結果を分析する

<details>
<summary>解答</summary>
C) 完全に自動でコードを本番環境にデプロイする

MCPを通じて、Copilotは外部データへのアクセス、複数プラットフォーム間でのコンテキスト維持、エージェントループの完了（探索、適応、調整のサイクル）が可能になります。しかし、本番環境への自動デプロイは開発者の監視と承認が必要であり、完全自動では行われません。
</details>

---

**Q2. MCPとエージェントモードを組み合わせる利点として正しいものは？**
- A) コードエディターのみの情報に限定される
- B) 手動作業が増加する
- C) 拡張コンテキスト、手動作業の削減、シームレスな統合
- D) カスタムコネクタが必ず必要になる

<details>
<summary>解答</summary>
C) 拡張コンテキスト、手動作業の削減、シームレスな統合

MCPとエージェントモードを組み合わせることで、複数のシステムからの情報を描画できる拡張コンテキスト、問題のオープンやワークフロー管理などの日常的な作業の自動化による手動作業の削減、カスタムコネクタを必要としないシームレスな統合が実現します。
</details>

---

**Q3. VS CodeでCopilot ChatのエージェントモードでMCPサーバーを使用する際の最初のステップは？**
- A) Dockerをインストールする
- B) Copilot チャットを開き、エージェントモードに切り替えてMCPサーバーツールをアクティブにする
- C) 構成ファイルを手動で作成する
- D) 外部APIの認証情報を入力する

<details>
<summary>解答</summary>
B) Copilot チャットを開き、エージェントモードに切り替えてMCPサーバーツールをアクティブにする

GitHub MCPサーバーをエージェントモードと組み合わせて使用するには、まずVisual Studio CodeでCopilot チャットを開き、エージェントモードに切り替えてMCPサーバーツールをアクティブにします。その後、「ツールの選択」をクリックして使用可能なMCPサーバー機能を表示できます。
</details>

---

**Q4. MCPとエージェントモードを効果的に使用するためのベストプラクティスとして正しくないものは？**
- A) 目標を明確にする
- B) コンテキストを提供する
- C) 境界を設定せずにCopilotに完全な自由を与える
- D) 確認を求める

<details>
<summary>解答</summary>
C) 境界を設定せずにCopilotに完全な自由を与える

MCPとエージェントモードのベストプラクティスには、目標を明確にする、コンテキストを提供する、境界を設定する、確認を求める、プロンプトファイルまたは指示を使用するが含まれます。境界を設定することは重要で、Copilotが計画を中止する（まだ変更を加えない）場合や、アクティブなMCPツールを制限することで、適切な制御を維持できます。
</details>

---

**Q5. エージェント機能がCopilotに提供する能力として正しいものは？**
- A) 常にユーザーのガイダンスが必要で、独立して作業できない
- B) 固定されたアプローチのみを使用し、コンテキストに基づいて変更できない
- C) 独立した作業、意思決定、適応と改善
- D) フィードバックを無視し、最初のアプローチを維持する

<details>
<summary>解答</summary>
C) 独立した作業、意思決定、適応と改善

エージェント機能は、Copilotに以下の能力を提供します：一定のガイダンスを必要とせずに複数ステップのワークフローを実行する「独立した作業」、コンテキストに基づいて使用するツールまたはアプローチを選択する「意思決定」、フィードバックに応答してアプローチを調整し結果を反復処理する「適応と改善」。
</details>

---

**Q6. MCPを使用したエージェントモードの動作を説明する「エージェントループ」とは何ですか？**
- A) 同じコードを繰り返し生成するプロセス
- B) プロセスを最初から再起動することなく、情報を動的にシークし、結果を分析し、情報に基づく次のステップを実行するサイクル
- C) ユーザーからのフィードバックを待つだけの待機状態
- D) 外部サービスへの接続を繰り返し試みるプロセス

<details>
<summary>解答</summary>
B) プロセスを最初から再起動することなく、情報を動的にシークし、結果を分析し、情報に基づく次のステップを実行するサイクル

エージェントループとは、Copilotがプロセスを最初から再起動することなく、情報を動的にシークし、結果を分析し、情報に基づく次のステップを実行する探索、適応、調整のサイクルです。これにより、必要な結果が得られるまで継続的に改善できます。
</details>

---

**Q7. 従来のCopilot使用とMCP+エージェントモードの違いとして正しいものは？**
- A) 従来のCopilotはプロジェクト全体を分析し、MCP+エージェントモードは単一ファイルのみを扱う
- B) 従来のCopilotは「プロンプト→応答」、MCP+エージェントモードは「タスク→計画→実行→反復」
- C) MCP+エージェントモードは外部ツールへのアクセスが制限される
- D) 従来のCopilotの方が自律性が高い

<details>
<summary>解答</summary>
B) 従来のCopilotは「プロンプト→応答」、MCP+エージェントモードは「タスク→計画→実行→反復」

従来のCopilot使用は単一ファイルまたは選択されたコードのスコープで「プロンプト→応答」の対話方法、低い自律性が特徴です。一方、MCP+エージェントモードはプロジェクト全体+外部システムのスコープで「タスク→計画→実行→反復」の対話方法、API・データベース・サービスへの直接アクセス、高い自律性が特徴です。
</details>

---

### 追加小テスト: GitHub MCPサーバー認定試験対策

**Q1. MCP は GitHub MCP Server のコンテキストで何を表していますか?**
- A) モデル コラボレーション プラットフォーム
- B) モデル コンテキスト プロトコル
- C) マルチクラウド プロバイダー
- D) モジュール式コード プロセス

<details>
<summary>解答</summary>
B) モデル コンテキスト プロトコル

MCPはModel Context Protocol（モデルコンテキストプロトコル）の略で、AIモデルが必要なツールやデータソースに接続するための一貫した安全な方法を提供する標準プロトコルです。
</details>

---

**Q2. ローカル MCP サーバーで GitHub MCP サーバーを使用する主な利点は何ですか?**
- A) プロジェクトごとに手動で構成する必要があります
- B) Docker または構成ファイルが不要
- C) モバイル デバイスでのみ機能する
- D) エンタープライズ認証のサポートがない

<details>
<summary>解答</summary>
B) Docker または構成ファイルが不要

GitHub MCP Serverの主な利点は、Dockerや手動の構成ファイルが不要で、ワンクリックOAuth認証による高速セットアップ、マルチプラットフォーム対応、自動スケーリングなどが含まれます。
</details>

---

**Q3. Visual Studio Code で GitHub MCP Server でサポートされている認証方法はどれですか?**
- A) OAuth のみ
- B) 個人用アクセス トークンのみ (PAT)
- C) OAuth と PAT
- D) ユーザー名とパスワード

<details>
<summary>解答</summary>
C) OAuth と PAT

VS CodeでGitHub MCP Serverを設定する際、推奨されるOAuth認証と、高度な制御が必要な場合の個人用アクセストークン（PAT）の両方がサポートされています。
</details>

---

**Q4. Docker でローカル MCP サーバーのセットアップを使用する理由**
- A) 認証に PAT を使用しないようにするには
- B) エンタープライズ ポリシーによって制限されているリソースまたは API にアクセスするには
- C) OAuth 認証のみを有効にするには
- D) すべての外部統合を無効にするには

<details>
<summary>解答</summary>
B) エンタープライズ ポリシーによって制限されているリソースまたは API にアクセスするには

DockerでローカルMCPサーバーをセットアップする主な理由は、GitHub Enterprise Serverを使用している企業向けで、組織のポリシーで制限されているリソースやAPIにアクセスする必要がある場合です。
</details>

---

**Q5. MCP サーバーと組み合わせた場合の Copilot エージェント モードの目的は何ですか?**
- A) セキュリティ スキャンのみを実行するには
- B) Copilot が複数ステップのワークフローを個別に計画および実行できるようにするには
- C) Copilot を単一ステップ のコマンドに制限するには
- D) Copilot をコード要約に制限するには

<details>
<summary>解答</summary>
B) Copilot が複数ステップのワークフローを個別に計画および実行できるようにするには

MCPサーバーとエージェントモードを組み合わせることで、Copilotは複数ステップのワークフローを自律的に計画・実行できるようになります。これにより、タスク→計画→実行→反復のサイクルで、外部データやAPIにアクセスしながら複雑な作業を処理できます。
</details>

---

**Q6. MCP サーバー構成で個人用アクセス トークン (PAT) が安全に使用されるようにするにはどうすればよいですか?**
- A) ソース ファイル内のトークンをハードコードする
- B) セキュリティで保護された入力プロンプトでトークンを入力する
- C) リポジトリでトークンをパブリックに共有する
- D) ワークスペースにプレーン テキストでトークンを保存する

<details>
<summary>解答</summary>
B) セキュリティで保護された入力プロンプトでトークンを入力する

PATを安全に使用するには、構成ファイルで`"password": true`オプションを使用したセキュアな入力プロンプトを設定し、トークンを入力します。トークンをハードコードしたり、プレーンテキストで保存したりすることは避けるべきです。
</details>

---

**Q7. VS Code で MCP サーバー ツールが動作しない場合、最初に試すべきトラブルシューティング手順はどれですか?**
- A) Docker を再インストールする
- B) VS Code で GitHub アカウントにサインインしていることを確認する
- C) PAT を削除する
- D) すべてのサーバー構成を削除する

<details>
<summary>解答</summary>
B) VS Code で GitHub アカウントにサインインしていることを確認する

MCPサーバーが動作しない場合、最初に確認すべきことはVS Code内でGitHubアカウントにサインインしているかどうかです。その後、PAT設定、構成ファイル、Dockerの状態（使用している場合）などを確認します。
</details>

---

**Q8. MCP サーバーがエージェント モードで Copilot の機能を拡張する方法の例を次に示します。**
- A) Copilot はコード補完のみを提案できます
- B) Copilot は、問題を開き、ワークフローを管理し、プラットフォーム間でタスクを実行できます
- C) Copilot が GitHub リポジトリと対話できない
- D) Copilot がセマンティック検索を無効にする

<details>
<summary>解答</summary>
B) Copilot は、問題を開き、ワークフローを管理し、プラットフォーム間でタスクを実行できます

MCPサーバーにより、Copilotは30以上のツールにアクセスでき、Issueのオープン・管理、Pull Requestの作成・管理、ワークフローの自動化、複数プラットフォーム間でのタスク実行などが可能になります。これにより、単なるコード補完を超えた包括的な開発支援が実現します。
</details>

---

### 追加小テスト: Copilot Chat認定試験対策（類似問題）

**Q1. GitHub Copilot Chatでコードのバグを修正する際、最も効果的なアプローチは何ですか？**
- A) エラーメッセージのみを貼り付ける
- B) 問題のあるコードを選択し、`/fix` スラッシュコマンドを使用して修正を依頼する
- C) 新しいファイルを作成してゼロからコードを書き直す
- D) コード全体をコピーして別のプロジェクトで実行する

<details>
<summary>解答</summary>
B) 問題のあるコードを選択し、`/fix` スラッシュコマンドを使用して修正を依頼する

Copilot Chatでは、問題のあるコードを選択し、`/fix` スラッシュコマンドを使用することで、コードの問題点を分析し、修正案を提示してもらえます。これにより、効率的にバグ修正を行うことができます。
</details>

---

**Q2. Copilot Chatの「チャット参加者」「スラッシュコマンド」「チャット変数」の主な目的は何ですか？**
- A) コードの実行速度を向上させる
- B) 外部データベースに接続する
- C) チャット体験を強化し、Copilotとの対話をより効果的にする
- D) ファイルを自動的にバックアップする

<details>
<summary>解答</summary>
C) チャット体験を強化し、Copilotとの対話をより効果的にする

チャット参加者（@workspace、@terminal など）、スラッシュコマンド（/explain、/fix、/tests など）、チャット変数（#file、#selection など）は、すべてチャット体験を強化し、より正確で関連性の高い応答を得るための機能です。
</details>

---

**Q3. Copilot Chatでコードの説明を生成するために使用するスラッシュコマンドは何ですか？**
- A) /doc
- B) /explain
- C) /describe
- D) /analyze

<details>
<summary>解答</summary>
B) /explain

`/explain` スラッシュコマンドを使用すると、選択したコードの詳細な説明を生成できます。これは複雑なコードロジックを理解したり、レガシーコードを学習したりする際に特に有用です。
</details>

---

**Q4. コードでエラーが発生した際、Copilot Chatはどのように支援できますか？**
- A) 自動的にコードを削除する
- B) エラーメッセージを無視する
- C) エラーの原因を分析し、修正方法を提案する
- D) 別のプログラミング言語への変換を推奨する

<details>
<summary>解答</summary>
C) エラーの原因を分析し、修正方法を提案する

Copilot Chatはエラーメッセージを分析し、問題の原因を特定して修正方法を提案できます。ターミナルでエラーが発生した場合は、エラーメッセージを選択して「Copilotで説明」オプションを使用することもできます。
</details>

---

**Q5. @workspace チャット参加者の主な機能は何ですか？**
- A) ターミナルコマンドの実行
- B) ワークスペース全体のコードベースをコンテキストとして使用して質問に回答する
- C) ファイルの削除
- D) Git履歴の表示

<details>
<summary>解答</summary>
B) ワークスペース全体のコードベースをコンテキストとして使用して質問に回答する

@workspace チャット参加者を使用すると、Copilot Chatはワークスペース全体のコードベースをコンテキストとして考慮し、プロジェクト構造、依存関係、関連ファイルを理解した上で質問に回答できます。
</details>

---

**Q6. @terminal チャット参加者を使用する主な利点は何ですか？**
- A) コードを自動的にコンパイルする
- B) ターミナル シェルとその内容に関するコンテキストを持ち、コマンドの提案や説明ができる
- C) ファイルを暗号化する
- D) ネットワーク設定を変更する

<details>
<summary>解答</summary>
B) ターミナル シェルとその内容に関するコンテキストを持ち、コマンドの提案や説明ができる

@terminal チャット参加者は、ターミナルの履歴やコンテキストを理解し、適切なコマンドの提案、エラーの説明、シェルスクリプトの作成支援などを行うことができます。
</details>

---

**Q7. Copilot Chatの出力を確認・修正する際のベストプラクティスは何ですか？**
- A) 出力をそのまま使用し、レビューしない
- B) 生成されたコードを常にレビューし、必要に応じてフォローアップの質問で改善を依頼する
- C) 出力を完全に無視して手動でコードを書く
- D) 最初の出力のみを使用し、追加の質問はしない

<details>
<summary>解答</summary>
B) 生成されたコードを常にレビューし、必要に応じてフォローアップの質問で改善を依頼する

Copilot Chatの出力は常に開発者がレビューする必要があります。期待通りでない場合は、フォローアップの質問を行うか、より具体的なコンテキストを提供して改善を依頼することで、より良い結果を得ることができます。
</details>

---

**Q8. Copilot Chatのパフォーマンスを最適化するためのヒントとして正しくないものはどれですか？**
- A) 明確で具体的な質問をする
- B) 関連するコードを選択してコンテキストを提供する
- C) できるだけ曖昧で一般的な質問をする
- D) スラッシュコマンドを活用して意図を明確にする

<details>
<summary>解答</summary>
C) できるだけ曖昧で一般的な質問をする

Copilot Chatのパフォーマンスを最適化するには、明確で具体的な質問をし、関連するコードをコンテキストとして提供し、スラッシュコマンドやチャット参加者を活用することが重要です。曖昧な質問は、あまり有用でない応答につながります。
</details>
