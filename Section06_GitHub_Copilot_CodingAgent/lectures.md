# IDEでのGitHub Copilot活用とコーディングエージェント

## 対応プラン
| 機能 | Free | Pro | Business | Enterprise |
|------|:----:|:---:|:--------:|:----------:|
| コード補完 | ○* | ○ | ○ | ○ |
| インライン提案 | ○* | ○ | ○ | ○ |
| インラインチャット | ○* | ○ | ○ | ○ |
| コーディングエージェント | - | ○ | ○ | ○ |
| タスクの割り当て・追跡 | - | ○ | ○ | ○ |

*Free: 月2,000補完まで

## 参照リソース
- [GitHub Copilot でのコード補完 - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/github-copilot-across-environments/2-code-completion-with-git-hub-copilot)
- [GitHub MCP Server を使用して AI ワークフローを簡素化する - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/mcp-server/2-simplify-workflow)
- [GitHub Copilot コーディング エージェントを使用して開発を加速する - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/github-copilot-code-agent/)
- [Copilot コーディング エージェントのカスタマイズ、拡張、検証 - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/github-copilot-code-agent/4-customize-extend-validate-copilot-code-agent)

---

## レクチャー1: IDEへのGitHub Copilotインストールと設定
**時間目安: 10分**

### 学習目標
- GitHub Copilotをトリガーするさまざまな方法を理解する
- 提案の操作方法をマスターする
- VS CodeでのGitHub Copilot拡張機能のインストール手順を習得する

### 内容

#### GitHub Copilotのインストール

**VS Codeでの拡張機能インストール手順**:
1. VS Codeを開く
2. 拡張機能ビュー（`Ctrl+Shift+X` / `Cmd+Shift+X`）を開く
3. 「GitHub Copilot」を検索
4. **インストール** をクリック
5. 初回はGitHubアカウントへのサインインが必要

**その他の対応IDE**:
- Visual Studio
- JetBrains スイート（IntelliJ、PyCharm、WebStorm等）
- Vim / Neovim
- Xcode（ベータ版）

#### GitHub Copilotのトリガー方法

GitHub Copilotを起動する3つの主な方法:

| トリガー方法 | 説明 | 例 |
|-------------|------|-----|
| **自動トリガー** | コードを入力すると自動的に提案が表示される（淡色表示） | 関数名を入力し始めると補完候補が表示 |
| **手動トリガー** | キーボードショートカットで明示的に起動 | コマンドパレットから「Copilot」コマンドを実行 |
| **コメント駆動** | 自然言語のコメントを書いてコードを生成 | `# ファイルを読み込む関数` と書くと実装を提案 |

#### 提案の操作方法

**キーボードショートカット一覧**:

| 操作 | Windows/Linux | Mac |
|------|---------------|-----|
| 提案を受け入れる | `Tab` または `→` | `Tab` または `→` |
| 提案を拒否する | `Esc` | `Esc` |
| 次の提案を表示 | `Alt + ]` | `Option + ]` |
| 前の提案を表示 | `Alt + [` | `Option + [` |
| 単語単位で受け入れる | `Ctrl + →` | `Cmd + →` |

#### インラインチャットの起動

エディター内で直接Copilotと対話できます：

| 機能 | Windows/Linux | Mac |
|------|---------------|-----|
| インラインチャットを起動 | `Ctrl + I` | `Cmd + I` |

**インラインチャットでできること**:
- 選択したコードについて質問
- コードの修正を依頼
- リファクタリングを実行
- ドキュメントの生成

#### 有効/無効の切り替え

**グローバル設定**:
- VS Code下部のステータスバーでCopilotアイコンをクリック
- 「有効にする」または「無効にする」を選択

**言語別設定**:
- 特定のプログラミング言語に対してのみ無効化可能
- 設定（`settings.json`）で細かく制御

```json
{
  "github.copilot.enable": {
    "*": true,
    "markdown": false,
    "plaintext": false
  }
}
```

---

## レクチャー2: コード補完機能の使い方
**時間目安: 12分**

### 学習目標
- GitHub Copilotでサポートされている言語を把握する
- 自動提案機能の仕組みと使い方を理解する
- コーディングコメントを活用した提案の質向上方法を習得する

### 内容

#### GitHub Copilotでサポートされている言語

GitHub Copilotは、以下のプログラミング言語とフレームワークに対して特に優れたサポートを提供します：

| 言語 | 特徴 |
|------|------|
| Python | データサイエンス、Web開発、自動化 |
| JavaScript | フロントエンド、Node.js開発 |
| Java | エンタープライズアプリケーション |
| TypeScript | 型安全なJavaScript開発 |
| Ruby | Web開発（Rails等） |
| Go | システムプログラミング、マイクロサービス |
| C# | .NET開発、ゲーム開発 |
| C++ | システムプログラミング、パフォーマンス重視のアプリ |

#### 自動提案機能

Copilotは、ユーザーが入力している間にリアルタイムでコード提案を行います：

- **現在の行の補完**: 入力中の行を完成させる提案
- **新しいコードブロック**: まったく新しいコードブロックの提案
- **ゴーストテキスト**: 提案はグレー表示のテキストとして表示される

#### コーディングスタイルへの適応

GitHub Copilotは、ユーザーのコーディングスタイルを学習し、適応します：

| 適応機能 | 説明 |
|----------|------|
| **メソッドの実装** | メソッド名の入力を開始すると、確立したコーディングスタイルに従って実装全体を提案 |
| **名前付け規則** | 変数、関数、クラスに対する好みの命名規則を学習 |
| **書式設定** | インデントスタイル、ブラケットの配置などに適応 |
| **設計パターン** | プロジェクトで使用されている設計パターンに合ったコードを提案 |

#### コメント駆動コード生成

コメントで関数の説明を書くと、Copilotが実装全体を提案します：

```python
# 文字列を反転させる関数
def reverse_string(s):
    return s[::-1]  # Copilotが提案
```

---

## レクチャー3: 【ハンズオン】インライン提案と複数提案の操作
**時間目安: 15分**

### 学習目標
- インライン提案の受け入れ・拒否操作をマスターする
- 複数提案ペインを使って異なる提案を比較する
- キーボードショートカットを使いこなせるようになる

### 内容

#### 複数提案ペイン

GitHub Copilotはコードブロックで作業している際に、グレー表示のコードスニペット（ゴーストテキスト）として提案を表示します。

**コントロールパネルの表示方法**:
1. 提案が表示されたらカーソルを合わせる
2. GitHub Copilotコントロールパネルが表示される
3. 前方または後方矢印ボタンをクリックして提案を切り替え

#### キーボードショートカット

**提案の切り替え**:

| 操作 | macOS | Windows/Linux |
|------|-------|---------------|
| 次の提案を表示 | `Option + ]` | `Alt + ]` |
| 前の提案を表示 | `Option + [` | `Alt + [` |

**提案の操作**:

| 操作 | キーボードショートカット |
|------|------------------------|
| 提案を受け入れる | `Tab` |
| 提案を拒否する | `Esc` |
| 単語単位で受け入れる | `Ctrl + →` (Windows) / `Cmd + →` (Mac) |

### ハンズオン演習

#### 演習1: 自動提案の基本操作

**目的**: 自動提案の受け入れと拒否を体験する

**手順**:
1. VS Codeで新しいPythonファイルを作成（`exercise1.py`）
2. 以下のコメントを入力：
   ```python
   # Calculate the factorial of a number
   def factorial(
   ```
3. 提案が表示されたら：
   - `Tab`キーで提案を受け入れる
   - または`Esc`キーで拒否して自分で書く

---

## レクチャー4: GitHub MCP ServerによるAIワークフローの強化
**時間目安: 10分**

### 学習目標
- モデルコンテキストプロトコル（MCP）の概念を理解する
- GitHub MCP Serverの利点と動作を把握する
- MCPを活用したAIワークフローの効率化方法を学ぶ

### MCPとは

MCP（モデルコンテキストプロトコル）は、**AIツールのUSB-C標準**のようなものです。AIモデルが必要なツールやデータソースに接続するための一貫した安全な方法を提供します。

#### MCPの主な特徴

| 特徴 | 説明 |
|------|------|
| **ツールライブラリへのアクセス** | AIモデルがすぐに使用できるツールのライブラリにアクセス可能 |
| **柔軟性** | ワークフローの一貫性を維持しながら、さまざまなAIプロバイダーと連携可能 |
| **統合性** | 既存の開発環境とプロセスへの統合が容易 |

### GitHub MCP Serverを使用する理由

通常、ローカルMCPサーバーを使用するには、Docker、トークン管理、手動構成が必要です。GitHub MCP Serverはこれらの問題を解決します：

| 利点 | 説明 |
|------|------|
| **Docker不要** | Docker または手動の構成ファイルが不要 |
| **簡単な認証** | 高速認証のためのワンクリック OAuth ログイン |
| **マルチプラットフォーム対応** | Web、デスクトップ、モバイル環境間でシームレスに作業可能 |
| **エンタープライズサポート** | Entra や Auth0 などのエンタープライズ ID プロバイダーをサポート |

### VS CodeでのGitHub MCPサーバー設定

#### OAuthを使用した設定（推奨）

**設定手順**:

1. **コマンドパレットを開く**
   - Windows/Linux: `Ctrl + Shift + P`
   - Mac: `Cmd + Shift + P`

2. **MCPサーバーを追加**
   - 「MCP: サーバーの追加」と入力し、Enterキーを押す

3. **接続タイプを選択**
   - 一覧から「**HTTP (HTTP または Server-Sent イベント)**」を選択

4. **サーバーURLを入力**
   - サーバーURLフィールドに以下を入力:
   ```
   https://api.githubcopilot.com/mcp/
   ```

5. **OAuth認証**
   - プロンプトが表示されたら「**許可**」を選択してGitHubアカウントにサインイン

---

## レクチャー5: コーディングエージェントの概要と有効化
**時間目安: 10分**

### GitHub Copilot コーディングエージェントとは

GitHub Copilot コーディングエージェントは、GitHub 自体で実行される**自律開発アシスタント**です。IDEでユーザーとペアリングするのではなく、エージェントは**バックグラウンドのチームメイト**のように機能します。

#### コーディングエージェントができること

| タスク | 説明 |
|--------|------|
| バグ修正 | バグと回帰を修正 |
| 機能実装 | 段階的な新機能を実装 |
| テスト生成 | テストカバレッジを改善、不足しているテストを生成 |
| ドキュメント | ドキュメントを更新または作成 |
| 技術的負債 | バックログ項目に対処 |

### コーディングエージェント vs エージェントモード

| 項目 | コーディングエージェント | エージェントモード |
|------|------------------------|-------------------|
| **動作場所** | GitHub.com（クラウド） | IDE（ローカル） |
| **実行環境** | GitHub Actions環境 | IDEセッション |
| **出力** | Pull Request を作成 | ローカルファイル編集 |
| **透明性** | コミット履歴で追跡可能 | プライベートセッション |
| **対話方法** | PRコメントで反復 | IDE内で直接対話 |

### 利用可能なプランとリポジトリ

#### 対応プラン
- Copilot Pro
- Copilot Pro+
- Copilot Business
- Copilot Enterprise

#### リポジトリ要件
- GitHub でホストされているリポジトリでのみ動作
- マネージドユーザーアカウント所有のリポジトリでは使用不可
- 明示的に無効化されていないリポジトリ

### タスクを委任する方法

エージェントに作業を委任する主な方法：

1. **Issue を Copilot に割り当て**
   - GitHub.com
   - GitHub Mobile
   - API/CLI

2. **Pull Request を作成するよう依頼**
   - GitHub の「エージェント」パネル
   - Copilot Chat
   - MCP をサポートする IDE

### 有効化方法

#### 組織所有のリポジトリ
組織またはエンタープライズ管理者が可用性を管理

#### 個人用リポジトリ
アカウント設定で可用性を構成：
- `github.com/settings/copilot/features` で確認

### コスト（GitHub Actions + PRU）

コーディングエージェントは2つのリソースを使用します：

| リソース | 説明 |
|---------|------|
| **GitHub Actions の実行時間** | エージェントが動作する一時的なビルド・テスト環境 |
| **Premium Request Units (PRU)** | 高度なモデル推論用（モデル要求ごとに1 PRU） |

> **注意**: 毎月のアクションと Premium 要求の許容量内で、追加料金なしでタスクを実行可能

---

## レクチャー6: セキュリティ、リスク、制限事項
**時間目安: 10分**

### セキュリティモデルと組み込みの保護

GitHub Copilot コーディングエージェントは、セキュリティとガバナンスを念頭に置いてゼロから設計されています。

#### 組み込みの保護機能

| 保護機能 | 説明 |
|---------|------|
| **ガバナンスの対象** | 組織と企業の設定によって可用性が管理される |
| **制限付き環境** | GitHub Actions 上のサンドボックス内で実行、ファイアウォールによるインターネットアクセス制限 |
| **ブランチの制限** | `copilot/` で始まるブランチのみ作成・プッシュ可能 |
| **アクセス許可対応** | 書き込みアクセス許可を持つユーザーにのみ応答 |
| **外部コラボレータールール** | エージェントからの下書き PR では書き込みアクセス許可を持つユーザーによる承認が必要 |
| **コンプライアンスと属性** | すべてのコミットはタスクを割り当てた開発者と共同編集される |

### リスクと軽減策

#### リスク1: エージェントがコードをプッシュする

**軽減策:**
- 書き込みアクセス権を持つユーザーのみがエージェントの作業をトリガー可能
- プッシュは `copilot/` ブランチに制限（メイン/マスターではない）
- GitHub Actions ワークフローは書き込みアクセス許可ユーザーが承認するまで実行されない
- 要求元は自身のエージェント PR を承認できない

#### リスク2: 機密情報へのアクセス

**軽減策:**
- エージェントのインターネットアクセスは既定でファイアウォールにより制限
- ポリシーごとにファイアウォールをカスタマイズまたは無効化可能

#### リスク3: プロンプトインジェクション

**軽減策:**
- 非表示の文字（HTML コメントなど）はユーザー入力をエージェントに渡す前にフィルター処理

### 既知の制限事項

#### ワークフローの制限

| 制限 | 説明 |
|------|------|
| リポジトリスコープ | 割り当てられた問題または PR と同じリポジトリでのみ変更可能 |
| コンテキストスコープ | 既定で割り当てられたリポジトリに制限（MCP で拡張可能） |
| PR 数 | タスクごとに 1 つの Pull Request のみ |
| 既存 PR | 自分が作成していない既存の PR を変更することはできない |

#### 互換性の制限

| 制限 | 説明 |
|------|------|
| コミット署名 | コミットに署名しない（署名必須の場合はマージ前に履歴を書き直す必要あり） |
| ランナー | GitHub でホストされる Ubuntu x64 ランナーが必要（セルフホステッド不可） |
| コンテンツ除外 | コンテンツの除外を優先しない（除外されたファイルを表示・更新可能） |
| パブリックコード | 「公開コードに一致する提案」ポリシーは適用されない |
| モデル選択 | 使用される AI モデルを変更できない（GitHub が選択） |

---

## レクチャー7: タスクの割り当て、追跡、問題解決
**時間目安: 12分**

### Copilot への Issue の割り当て

Copilot に Issue を割り当てると、エージェントは以下の流れで動作します：

1. Issue に対する 👀 の反応を追加（確認）
2. 専用の `copilot/` ブランチを作成
3. Issue にリンクされた下書き Pull Request を開く
4. GitHub Actions を利用した環境内でエージェントセッションを開始
5. コミットをブランチにプッシュし、PR 本文をステータスメッセージで更新
6. 完了時に「Copilot finished work」イベントを投稿し、レビューを要求

### 割り当て方法

#### GitHub.com での割り当て
1. リポジトリの「Issues」タブに移動
2. 委任する Issue を開く
3. 右側のサイドバーの「Assignees」で「Copilot」を選択

#### GitHub CLI での割り当て
```bash
gh issue edit <issue-number> --add-assignee copilot
```

#### GraphQL API での割り当て

**可用性チェック:**
```graphql
query {
  repository(owner: "octo-org", name: "octo-repo") {
    suggestedActors(capabilities: [CAN_BE_ASSIGNED], first: 100) {
      nodes { login __typename ... on Bot { id } ... on User { id } }
    }
  }
}
```

### Copilot の進行状況の追跡

| フェーズ | 確認方法 |
|---------|---------|
| **即時確認** | Issue に 👀 の反応が追加される |
| **下書き PR 作成** | Issue のタイムラインに新しいイベントが表示 |
| **アクティブセッション** | PR タイムラインに「Copilot started work」が表示 |
| **ライブセッションログ** | 「エージェント」ページから過去および現在のセッションを表示 |
| **完了** | PR タイムラインに「Copilot finished work」が表示、レビュー要求通知 |

### @copilot による反復処理

Pull Request コメントで `@copilot` をメンションすることで、作業を反復処理できます。

**注意:**
- リポジトリへの書き込みアクセス許可を持つユーザーからのコメントのみ処理される
- Copilot はコメントに 👀 の反応を投稿して要求を受信したことを確認

### 承認とワークフロー

- Copilot が作成した PR は常に**ドラフト状態**
- マージ前に**人による承認が必要**
- GitHub Actions ワークフローは自動実行されない（「承認してワークフローを実行」をクリック）
- PR を作成した開発者は自身の PR を承認できない

### トラブルシューティング

| 問題 | 対処法 |
|------|--------|
| 「Assignees」リストに Copilot がない | 対象プラン（Pro, Pro+, Business, Enterprise）を確認。エージェントが無効になっていないか確認 |
| EMU 個人用リポジトリで使用不可 | 組織所有のリポジトリを使用 |
| Issue 割り当て後に何も起こらない | 最新情報に更新し、👀 反応があるか確認、ドラフト PR を確認 |
| エージェントが PR コメントに応答しない | 書き込みアクセス権を確認、@copilot がメンションされているか確認 |
| スタックしているように見える | セッションは1時間後にタイムアウト。Issue の割り当て解除/再割り当て |
| Actions が実行されない | 「承認してワークフローを実行」をクリック |
| チャットからの「Pull Request を作成できません」 | エージェントが使用可能か確認。IDE では @github をメンション |
| ファイアウォールの警告 | インターネットは既定で制限。ブロックされたアドレスを確認し、必要に応じてファイアウォールをカスタマイズ |
| 画像が取得されない | 最大イメージサイズは 3.00 MiB。大きい画像は削除される |
| プッシュが CI テストを通過しない | `.github/copilot-instructions.md` で明確なリポジトリレベルのガイダンスを提供 |

### GraphQL API を使用した詳細な問題の割り当て

プログラムで Copilot に問題を割り当てる場合、GraphQL API を使用できます。

#### リポジトリ ID を取得する
```graphql
query {
  repository(owner: "octo-org", name: "octo-repo") { id }
}
```

#### 新しい問題を作成して割り当てる
```graphql
mutation {
  createIssue(
    input: {
      repositoryId: "REPOSITORY_ID",
      title: "Implement comprehensive unit tests",
      body: "DETAILS",
      assigneeIds: ["BOT_ID"]
    }
  ) {
    issue { id title assignees(first: 10) { nodes { login } } }
  }
}
```

#### 既存の問題を割り当てる
まず問題 ID を取得：
```graphql
query {
  repository(owner: "monalisa", name: "octocat") {
    issue(number: 9000) { id title }
  }
}
```

次に `replaceActorsForAssignable` 変更を使用：
```graphql
mutation {
  replaceActorsForAssignable(
    input: { assignableId: "ISSUE_ID", actorIds: ["BOT_ID"] }
  ) {
    assignable {
      ... on Issue {
        id title
        assignees(first: 10) { nodes { login } }
      }
    }
  }
}
```

> **ポイント**: このアプローチは、Copilot を自動化されたワークフローに統合する場合に役立ちます。

### 参照
- [コパイロット コーディング エージェント タスクの割り当て、追跡、問題解決 - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/github-copilot-code-agent/3-assign-track-troubleshoot-copilot-code-agent-tasks)

---

## レクチャー8: カスタマイズ、拡張、検証
**時間目安: 10分**

### 開発環境の準備

#### copilot-setup-steps.yml の作成

リポジトリの既定のブランチに `.github/workflows/copilot-setup-steps.yml` を作成します。

**TypeScript の例:**
```yaml
name: "Copilot Setup Steps"

on:
  workflow_dispatch:
  push:
    paths:
      - .github/workflows/copilot-setup-steps.yml
  pull_request:
    paths:
      - .github/workflows/copilot-setup-steps.yml

jobs:
  copilot-setup-steps:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
      - name: Install JavaScript dependencies
        run: npm ci
```

#### 許可されている構成キー
- `steps`
- `permissions`
- `runs-on`
- `container`
- `services`
- `snapshot`
- `timeout-minutes`（≤ 59）

> **注意:** セットアップワークフローはスタンドアロンで実行され（検証できるように）、エージェントが開始される前に自動的に実行されます。安全なロールバックを可能にするために、任意の `actions/checkout` フェッチの深さはオーバーライドされます。

#### 大規模な GitHub ホステッドランナーの使用

より多くのリソースが必要な場合、大規模なランナーを使用できます：

1. 最初に大きなランナーを追加する
2. `copilot-setup-steps.yml` で `runs-on` をラベル/グループに設定（例: `ubuntu-4-core`）

> **注意:** Ubuntu x64 ランナーのみがサポートされています。セルフホステッドランナーはサポートされていません。

#### Git LFS の有効化

Git Large File Storage を使用するリポジトリでは、セットアップ手順で有効にします：

```yaml
jobs:
  copilot-setup-steps:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v5
        with:
          lfs: true
```

#### ファイアウォールのカスタマイズ

- 既定では、流出リスクを軽減するためにインターネットアクセスが制限されています
- 必要に応じて、組織のポリシーに従ってファイアウォールをカスタマイズまたは無効化できます

### モデルコンテキストプロトコル（MCP）による拡張

MCP は、ツールとデータに LLM を接続するためのオープンな標準です。

#### 既定の MCP サーバー

| サーバー | 機能 |
|---------|------|
| **GitHub MCP サーバー** | Issue、PR、GitHub データにアクセス（読み取り専用トークン使用） |
| **Playwright MCP サーバー** | Web ページの読み取り、操作、スクリーンショット取得 |

#### MCP 構成のベストプラクティス

- パフォーマンスと出力品質への影響についてサードパーティの MCP サーバーを確認
- 読み取りツールを優先、書き込みツールは必要なものだけを許可
- 保存前に MCP 構成を慎重に検証

> **注意:** Copilot コーディングエージェントでは MCP ツールのみサポート（リソースやプロンプトは不可）。OAuth を必要とするリモート MCP サーバーは非対応。

#### リポジトリでの MCP 構成

管理者は、リポジトリ内の JSON 構成を使用して MCP サーバーを宣言できます。構成が完了すると、エージェントは使用可能なツールを自律的に使用します（使用ごとの承認プロンプトは使用されません）。

詳細については「MCP を使用した GitHub Copilot コーディング エージェントの拡張」を参照してください。

### エージェント出力のテストと検証

品質とセキュリティについては引き続き開発者が責任を負います。

#### 検証のベストプラクティス

| プラクティス | 説明 |
|-------------|------|
| **CI を実行** | すべてのエージェント PR でテスト、リンター、スキャンを実行 |
| **手動検査** | 影響の大きい領域や機密性の高い領域を手動で検査 |
| **テスト生成を依頼** | 例: "Add Jest unit tests for all functions in src/utils/" |
| **ルールセット適用** | エージェント PR がテストに合格することを必須に |
| **ラベル付け** | エージェント PR にラベルを付けて監視・トリアージ |
| **命令を反復** | 繰り返しミスがある場合は `.github/copilot-instructions.md` を更新 |

#### PRU（Premium Request Units）を意図的に検証に使用する

PRU を利用して、より詳細な検証タスクを実行できます：

| 検証タスク | 説明 |
|-----------|------|
| テストカバレッジの拡張 | 不足しているテストケースを特定して生成 |
| ディレクトリ間の監査 | 複数のディレクトリにわたるコード品質を確認 |
| 危険なエリアのスキャン | セキュリティリスクのある箇所を特定 |

> **ヒント:** ライトウェイトチェックでは消費される PRU が少ないため、値を最大化するために意図的に適用しましょう。

### 参照
- [Copilot コーディング エージェントのカスタマイズ、拡張、検証 - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/github-copilot-code-agent/4-customize-extend-validate-copilot-code-agent)

---

## レクチャー9: 責任ある使用とベストプラクティス
**時間目安: 8分**

### エージェントのしくみ（エンドツーエンド）

1. **プロンプト処理**
   - Issue、PR コメント、または Copilot Chat メッセージからタスクを取得
   - 入力形式: 自然言語、コードスニペット、画像

2. **言語モデルの分析**
   - プロンプトを大規模言語モデルで分析
   - タスクの理由付けと必要なツールの活用

3. **応答の生成**
   - 自然言語の提案とコードの提案を生成

4. **出力の書式設定**
   - 変更内容に合わせて PR の説明を更新
   - アクセスできなかったリソースに関する補足情報を含む場合あり

### 活用事例

| ユースケース | 説明 |
|-------------|------|
| **コードベースのメンテナンス** | セキュリティ修正、依存関係アップグレード、リファクタリング |
| **ドキュメント** | ドキュメントの更新と新規作成 |
| **機能開発** | 機能リクエストの段階的な実現 |
| **テストカバレッジ改善** | 追加のテストスイート開発 |
| **プロトタイプ作成** | 新しい概念のグリーンフィールド開発 |

### パフォーマンス向上のコツ

#### タスクのスコープを適切に設定

以下の情報を提供してください：
- 解決すべき問題または必要な作業の明確な説明
- 適切なソリューションの受け入れ基準（単体テストが必要かなど）
- 変更する必要があるファイルに関するヒント

#### カスタム命令の追加

`.github/copilot-instructions.md` を追加して、エージェントが変更をビルド、テスト、検証する方法を理解できるようにします。

### セキュリティ対策

#### 特権エスカレーションの回避
- 書き込みアクセス権を持つユーザーからの対話にのみ応答
- エージェント PR によるアクション ワークフローは承認が必要
- 非表示の文字はフィルター処理

#### Copilot のアクセス許可の制約
- PR を作成しているリポジトリにのみアクセス
- プッシュは `copilot/` で始まるブランチに限定
- 組織/リポジトリのシークレットにはアクセス不可

#### データ流出の防止
- ファイアウォールは既定で有効
- コードや機密データの偶発的・悪意のある流出を防止

### 制限事項の理解

| 制限 | 説明 |
|------|------|
| **限られた範囲と品質** | 特定のコード構造や言語での品質差 |
| **潜在的なバイアス** | トレーニングデータによるバイアスの可能性 |
| **セキュリティリスク** | レビューされない場合は機密情報を公開する可能性 |
| **不正確なコード** | 意味的/構文的に間違っている可能性 |
| **パブリックコード** | 参照が提供されない場合あり |

---

## レクチャー10: 【確認テスト】IDEでのGitHub Copilot活用
**時間目安: 10分**

### 小テスト: IDEでのGitHub Copilot

**Q1. GitHub CopilotをVS Codeでトリガーする方法として正しいものをすべて選択してください。**
- A) 自動トリガー（コード入力時に自動表示）
- B) 手動トリガー（キーボードショートカット）
- C) コメント駆動（自然言語コメントからコード生成）
- D) 音声コマンド

<details>
<summary>解答</summary>
A) 自動トリガー、B) 手動トリガー、C) コメント駆動

GitHub Copilotは、自動トリガー、手動トリガー、コメント駆動の3つの方法で起動できます。音声コマンドはサポートされていません。
</details>

---

**Q2. GitHub Copilotの提案を受け入れるためのキーボードショートカットは？**
- A) Enter
- B) Tab
- C) Ctrl + Enter
- D) Space

<details>
<summary>解答</summary>
B) Tab

Tabキーを押すことで、Copilotの提案（ゴーストテキスト）を受け入れることができます。
</details>

---

**Q3. 次の提案を表示するためのキーボードショートカットは？（Windows/Linux）**
- A) Ctrl + ]
- B) Alt + ]
- C) Shift + ]
- D) Tab + ]

<details>
<summary>解答</summary>
B) Alt + ]

Windows/LinuxではAlt + ]、macOSではOption + ]で次の提案を表示できます。
</details>

---

**Q4. インラインチャットを起動するためのキーボードショートカットは？（Windows/Linux）**
- A) Ctrl + Shift + I
- B) Ctrl + I
- C) Alt + I
- D) Ctrl + Enter

<details>
<summary>解答</summary>
B) Ctrl + I

Windows/LinuxではCtrl + I、macOSではCmd + Iでインラインチャットを起動できます。
</details>

---

**Q5. GitHub Copilotが特に優れたサポートを提供するプログラミング言語として正しくないものは？**
- A) Python
- B) JavaScript
- C) COBOL
- D) TypeScript

<details>
<summary>解答</summary>
C) COBOL

Python、JavaScript、TypeScript、Java、Ruby、Go、C#、C++などの主要言語に対して特に優れたサポートを提供しますが、COBOLは主要なサポート言語には含まれていません。
</details>

---

**Q6. GitHub Copilotの「ゴーストテキスト」とは何ですか？**
- A) 削除されたコードの履歴
- B) 提案がグレー表示で表示されるテキスト
- C) エラーメッセージ
- D) コメントアウトされたコード

<details>
<summary>解答</summary>
B) 提案がグレー表示で表示されるテキスト

ゴーストテキストは、Copilotの提案がエディタ内でグレー（淡色）表示されるテキストのことです。Tabキーで受け入れることができます。
</details>

---

**Q7. MCP（モデルコンテキストプロトコル）の説明として最も適切なものは？**
- A) セキュリティスキャンのプロトコル
- B) AIツールのUSB-C標準のような、AIモデルがツールやデータソースに接続するための一貫した方法
- C) コードをコンパイルするためのプロトコル
- D) バージョン管理のプロトコル

<details>
<summary>解答</summary>
B) AIツールのUSB-C標準のような、AIモデルがツールやデータソースに接続するための一貫した方法

MCPは、AIモデルが必要なツールやデータソースに接続するための一貫した安全な方法を提供するプロトコルです。
</details>

---

**Q8. GitHub MCP Serverを使用する利点として正しくないものは？**
- A) Docker不要
- B) ワンクリックOAuth認証
- C) オフラインでの使用が可能
- D) マルチプラットフォーム対応

<details>
<summary>解答</summary>
C) オフラインでの使用が可能

GitHub MCP Serverはクラウドベースのサービスであり、オフラインでの使用はサポートされていません。Docker不要、簡単な認証、マルチプラットフォーム対応が主な利点です。
</details>

---

**Q9. VS CodeでGitHub MCP Serverを設定する際のサーバーURLは？**
- A) https://github.com/mcp/
- B) https://api.github.com/mcp/
- C) https://api.githubcopilot.com/mcp/
- D) https://mcp.github.com/api/

<details>
<summary>解答</summary>
C) https://api.githubcopilot.com/mcp/

GitHub MCP ServerのURLは `https://api.githubcopilot.com/mcp/` です。
</details>

---

**Q10. GitHub Copilotの提案を単語単位で受け入れるためのキーボードショートカットは？（Windows）**
- A) Tab
- B) Ctrl + Tab
- C) Ctrl + →
- D) Alt + →

<details>
<summary>解答</summary>
C) Ctrl + →

WindowsではCtrl + →、macOSではCmd + →で提案を単語単位で受け入れることができます。
</details>

---

## レクチャー11: 【確認テスト】コーディングエージェント
**時間目安: 10分**

### 小テスト: GitHub Copilot コーディングエージェント

**Q1. GitHub Copilot コーディングエージェントとエージェントモードの主な違いは何ですか？**
- A) コーディングエージェントは IDE 内で動作し、エージェントモードは GitHub.com で動作する
- B) コーディングエージェントは GitHub.com で動作し、Pull Request を作成する。エージェントモードは IDE 内で動作する
- C) 両者に違いはない
- D) コーディングエージェントはテストのみを生成する

<details>
<summary>解答</summary>
B) コーディングエージェントは GitHub.com で動作し、Pull Request を作成する。エージェントモードは IDE 内で動作する

コーディングエージェントは GitHub Actions 環境で自律的に実行され、結果として PR を作成します。エージェントモードは IDE セッションでローカル編集を直接実行します。
</details>

---

**Q2. Copilot コーディングエージェントを利用できるプランはどれですか？（すべて選択）**
- A) Copilot Free
- B) Copilot Pro
- C) Copilot Business
- D) Copilot Enterprise

<details>
<summary>解答</summary>
B) Copilot Pro、C) Copilot Business、D) Copilot Enterprise

また、Copilot Pro+ も利用可能です。Copilot Free では利用できません。
</details>

---

**Q3. コーディングエージェントがプッシュできるブランチ名の形式は？**
- A) main/ で始まるブランチ
- B) feature/ で始まるブランチ
- C) copilot/ で始まるブランチ
- D) 任意のブランチ名

<details>
<summary>解答</summary>
C) copilot/ で始まるブランチ

セキュリティ上の理由から、エージェントは copilot/ で始まるブランチのみを作成してプッシュできます。これにより、メインブランチへの直接的な影響を防ぎます。
</details>

---

**Q4. Copilot コーディングエージェントに Issue を割り当てた後、最初に表示される確認は何ですか？**
- A) コメントが追加される
- B) 👀 の反応が追加される
- C) メールが送信される
- D) Slack 通知が送信される

<details>
<summary>解答</summary>
B) 👀 の反応が追加される

Copilot に Issue を割り当てると、エージェントは Issue に対する 👀 の反応を追加することで確認を示します。
</details>

---

**Q5. Copilot コーディングエージェントによって作成された Pull Request の状態は？**
- A) オープン状態
- B) クローズ状態
- C) ドラフト状態
- D) マージ済み状態

<details>
<summary>解答</summary>
C) ドラフト状態

Copilot によって作成された PR は常にドラフト状態であり、マージ前に人による承認が必要です。
</details>

---

**Q6. コーディングエージェントの PR で GitHub Actions ワークフローを実行するには？**
- A) 自動的に実行される
- B) 「承認してワークフローを実行」をクリックする
- C) Issue を再割り当てする
- D) ワークフローは実行できない

<details>
<summary>解答</summary>
B) 「承認してワークフローを実行」をクリックする

エージェントによってトリガーされる GitHub Actions ワークフローは自動的には実行されません。書き込みアクセス許可を持つユーザーが承認する必要があります。
</details>

---

**Q7. コーディングエージェントがアクセスできないものはどれですか？**
- A) 割り当てられた Issue の内容
- B) リポジトリのコード
- C) 組織/リポジトリのアクション シークレット
- D) Pull Request のコメント

<details>
<summary>解答</summary>
C) 組織/リポジトリのアクション シークレット

エージェントは実行時に組織/リポジトリアクションのシークレットまたは変数にアクセスできません。Copilot 環境に追加されたシークレット/変数のみがエージェントに渡されます。
</details>

---

**Q8. MCP（モデルコンテキストプロトコル）の役割として正しいものは？**
- A) セキュリティスキャンを実行する
- B) ツールとデータに LLM を接続するためのオープンな標準
- C) コードをコンパイルする
- D) テストを自動実行する

<details>
<summary>解答</summary>
B) ツールとデータに LLM を接続するためのオープンな標準

MCP はエージェントの機能を拡張するために使用され、ローカルまたはリモートの MCP サーバーによって提供されるツールを使用できます。
</details>

---

**Q9. エージェントの開発環境を準備するために作成するファイルはどれですか？**
- A) .github/workflows/ci.yml
- B) .github/workflows/copilot-setup-steps.yml
- C) .github/copilot-config.yml
- D) copilot.json

<details>
<summary>解答</summary>
B) .github/workflows/copilot-setup-steps.yml

このファイルでツール、依存関係、シークレットをプレインストールして、エージェントの開発環境を準備できます。
</details>

---

**Q10. コーディングエージェントの制限として正しくないものはどれですか？**
- A) 割り当てられたリポジトリと同じリポジトリでのみ変更できる
- B) タスクごとに複数の Pull Request を作成できる
- C) コミットに署名しない
- D) セルフホステッドランナーはサポートされていない

<details>
<summary>解答</summary>
B) タスクごとに複数の Pull Request を作成できる

これは正しくありません。エージェントはタスクごとに 1 つの Pull Request のみを開きます。
</details>

---

**Q11. Copilot コーディングエージェントのセキュリティ対策として、プロンプトインジェクション攻撃を防ぐために行われていることは？**
- A) すべての入力を暗号化する
- B) 非表示の文字（HTML コメントなど）をフィルター処理する
- C) 外部 API へのアクセスを完全に禁止する
- D) ユーザー認証を二重にする

<details>
<summary>解答</summary>
B) 非表示の文字（HTML コメントなど）をフィルター処理する

これにより、コメントや Issue で有害な指示が隠される可能性を低減しています。
</details>

---

**Q12. Copilot コーディングエージェントが対話に応答するのは、どのようなユーザーからの要求ですか？**
- A) リポジトリを閲覧できるすべてのユーザー
- B) 書き込みアクセス許可を持つユーザーのみ
- C) 組織の管理者のみ
- D) Copilot を有効にしているすべてのユーザー

<details>
<summary>解答</summary>
B) 書き込みアクセス許可を持つユーザーのみ

エージェントはリポジトリへの書き込みアクセス許可を持つユーザーからのコメントにのみ応答します。
</details>

---

### 追加小テスト: Microsoft Learn 認定試験形式

**Q13. 従来の JavaScript アプリケーションを最新のフレームワークに移行するように GitHub Copilot コーディングエージェントに指示した場合、エージェントが自律的に実行する可能性が高いアクションは何ですか？**
- A) 依存関係やプロジェクト構造を変更せずに、個々のファイルに対してのみインラインコード補完を提供する
- B) 関連するファイルの識別、依存関係の更新、複数のファイル間での既存コードのリファクタリング、テストを実行して変更の検証を行う
- C) 移行が必要な理由を説明するドキュメントを生成するが、実際のコード実装は開発者に任せる
- D) テストを自律的に実行することなく、コード変更の各ステップで手動入力を開発者に求める

<details>
<summary>解答</summary>
B) 関連するファイルの識別、依存関係の更新、複数のファイル間での既存コードのリファクタリング、テストを実行して変更の検証を行う

コーディングエージェントはバックグラウンドで自律的に動作し、複雑なタスクを処理できます。関連ファイルを識別し、依存関係を更新し、複数ファイル間でコードをリファクタリングし、テストを実行して変更を検証するという一連の処理を自律的に行います。
</details>

---

**Q14. GitHub Copilot コーディングエージェントを使用する場合のプロジェクトドキュメントファイル（README.md など）の役割は何ですか？**
- A) 開発者向けの参照ドキュメントとしてのみ機能し、エージェントの動作には影響しない
- B) エージェントがプロジェクトの意図した動作を理解するのに役立ち、自律的にタスクを実行する方法に影響を与える
- C) エージェントのコードファイルへのアクセスを制限し、不要な変更を防ぐ
- D) エージェントはドキュメントファイルを完全に無視し、ファイル構造とソースコードのみに依存する

<details>
<summary>解答</summary>
B) エージェントがプロジェクトの意図した動作を理解するのに役立ち、自律的にタスクを実行する方法に影響を与える

エージェントはプロジェクトのファイル、依存関係、およびコンテキストを使用してタスクを効果的に完了します。README などのドキュメントファイルはプロジェクトの意図を理解するための重要なコンテキストを提供します。
</details>

---

**Q15. GitHub Copilot コーディングエージェントを使用する場合、開発者が考慮すべき重要な制限事項は何ですか？**
- A) すべてのコード生成後に手動構成を有効にする必要がある
- B) 明確なパターンを欠く高度に特殊なドメイン知識や微妙なビジネスロジックでは問題が発生する可能性がある
- C) コードスニペットの生成のみをサポートし、テストを自律的にリファクタリングまたは実行することはできない
- D) 明示的に開発者が提供するコンテキストのみに依存し、プロジェクトの構造と依存関係を分析することはできない

<details>
<summary>解答</summary>
B) 明確なパターンを欠く高度に特殊なドメイン知識や微妙なビジネスロジックでは問題が発生する可能性がある

エージェントは強力ですが、特殊なドメインロジック、微妙なビジネスルール、または重要なプロジェクトコンテキストが不足している場合は問題が発生する可能性があります。
</details>

---

### 追加小テスト: タスクの割り当て、追跡、問題解決

**Q16. GraphQL API で Copilot コーディングエージェントの可用性を確認するために、クエリでチェックするフィールドは何ですか？**
- A) availableAgents
- B) suggestedActors
- C) copilotStatus
- D) assignableUsers

<details>
<summary>解答</summary>
B) suggestedActors

リポジトリの `suggestedActors` に対してクエリを実行し、`copilot-swe-agent` が推奨されるアクターとして表示されることを確認することで、コーディングエージェントが使用可能であることを確認できます。
</details>

---

**Q17. Pull Request のコメントで @copilot をメンションした際、Copilot が要求を受信したことを示す方法は？**
- A) コメントに「確認しました」と返信する
- B) コメントに 👀 の反応を投稿する
- C) Issue にラベルを追加する
- D) メールで通知を送信する

<details>
<summary>解答</summary>
B) コメントに 👀 の反応を投稿する

Copilot はコメントに 👀 の反応を投稿して要求を受信したことを確認し、再開時に Pull Request タイムラインに「Copilot started work」を追加します。
</details>

---

**Q18. Copilot コーディングエージェントのファイアウォールに関する正しい記述はどれですか？**
- A) ファイアウォールは既定で無効になっている
- B) ファイアウォールは既定で有効であり、インターネットアクセスが制限されている
- C) ファイアウォールはカスタマイズできない
- D) ファイアウォールは組織レベルでのみ設定可能

<details>
<summary>解答</summary>
B) ファイアウォールは既定で有効であり、インターネットアクセスが制限されている

エージェントのインターネットアクセスは既定でファイアウォールにより制限されています。警告にはブロックされたアドレスとコマンドが一覧表示され、必要に応じてカスタマイズまたは無効化できます。
</details>

---

**Q19. 画像を Copilot コーディングエージェントに渡す際の制限は何ですか？**
- A) 画像は一切サポートされていない
- B) 最大イメージサイズは 3.00 MiB で、大きい画像は削除される
- C) 最大イメージサイズは 10 MB
- D) PNG 形式のみサポートされている

<details>
<summary>解答</summary>
B) 最大イメージサイズは 3.00 MiB で、大きい画像は削除される

Copilot コーディングエージェントでは、最大イメージサイズが 3.00 MiB に制限されており、これを超える大きい画像は削除されます。
</details>

---

**Q20. Copilot がスタックしているように見える場合、セッションは何時間後にタイムアウトしますか？**
- A) 30分後
- B) 1時間後
- C) 2時間後
- D) 24時間後

<details>
<summary>解答</summary>
B) 1時間後

エージェントセッションは回復する可能性がありますが、1時間後にタイムアウトします。問題が解決しない場合は、Issue の割り当てを解除して再割り当てするか、コメントを再投稿して再試行できます。
</details>

---

### 追加小テスト: カスタマイズ、拡張、検証

**Q21. copilot-setup-steps.yml で許可されている timeout-minutes の最大値は？**
- A) 30分
- B) 59分
- C) 60分
- D) 120分

<details>
<summary>解答</summary>
B) 59分

copilot-setup-steps ジョブの timeout-minutes は最大 59 分に制限されています。
</details>

---

**Q22. Copilot コーディングエージェントで大規模なGitHubホステッドランナーを使用する場合、サポートされているランナーの種類は？**
- A) Windows x64 ランナーのみ
- B) Ubuntu x64 ランナーのみ
- C) macOS ランナーのみ
- D) すべてのランナータイプ

<details>
<summary>解答</summary>
B) Ubuntu x64 ランナーのみ

大規模なGitHubホステッドランナーを使用する場合、Ubuntu x64 ランナーのみがサポートされています。セルフホステッドランナーはサポートされていません。
</details>

---

**Q23. Git LFS を使用するリポジトリで Copilot コーディングエージェントを使用する場合、copilot-setup-steps.yml で設定する必要があるオプションは？**
- A) `git-lfs: true`
- B) `lfs: true`
- C) `large-files: enabled`
- D) `storage: lfs`

<details>
<summary>解答</summary>
B) `lfs: true`

actions/checkout アクションで `lfs: true` オプションを設定することで、Git Large File Storage を有効にできます。
</details>

---

**Q24. Copilot コーディングエージェントの MCP（モデルコンテキストプロトコル）でサポートされていないものは？**
- A) MCP ツール
- B) MCP リソース
- C) ローカル MCP サーバー
- D) リモート MCP サーバー（認証不要の場合）

<details>
<summary>解答</summary>
B) MCP リソース

Copilot コーディングエージェントでは MCP ツールのみがサポートされます。リソースやプロンプトはサポートされていません。また、OAuth を必要とするリモート MCP サーバーも非対応です。
</details>

---

**Q25. Copilot コーディングエージェントの既定の MCP サーバーに含まれないものは？**
- A) GitHub MCP サーバー
- B) Playwright MCP サーバー
- C) Slack MCP サーバー
- D) なし（すべて含まれる）

<details>
<summary>解答</summary>
C) Slack MCP サーバー

既定の MCP サーバーは GitHub MCP サーバーと Playwright MCP サーバーの2つです。Slack MCP サーバーは既定では含まれていません。
</details>
