# GitHub Copilot コードレビューとPull Request

## 対応プラン
| 機能 | Free | Pro | Business | Enterprise |
|------|:----:|:---:|:--------:|:----------:|
| 基本的なPRサマリー | - | ○ | ○ | ○ |
| Copilotによるコードレビュー | - | ○ | ○ | ○ |
| 自動レビュー設定（個人） | - | ○ | - | - |
| 自動レビュー設定（組織） | - | - | ○ | ○ |
| PRU利用機能 | - | ○ | ○ | ○ |
| カスタムレビュー手順 | - | - | ○ | ○ |

## 参照リソース
- [GitHub Copilot がレビュー プロセスに追加するもの - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/code-reviews-pull-requests-github-copilot/2-github-copilot-review-process)
- [GitHub.com の校閲者としての Copilot の使用 - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/code-reviews-pull-requests-github-copilot/3-copilot-reviewer-github)
- [問題を早期にキャッチし、Copilotでレビューを自動化する - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/code-reviews-pull-requests-github-copilot/4-issues-early-automated-reviews-copilot)
- [影響の測定と Premium 要求ユニット (PRU) の最適化 - Microsoft Learn](https://learn.microsoft.com/ja-jp/training/modules/code-reviews-pull-requests-github-copilot/5-impact-optimization-premium-request-units)

---

## レクチャー1: Copilotがレビュープロセスに追加するもの
**時間目安: 10分**

### 学習目標
- コードレビューでCopilotの主な機能を特定できる
- PRU（Premium Request Units）が高度なレビュー機能をロック解除する方法を理解する
- Copilotレビューが開発者を補完・支援するさまざまな方法を認識する

### コードレビューの課題とCopilotの役割

コードレビューとpull requestレビューは品質に不可欠ですが、時間がかかり、不均等になる場合もあります。開発者は、多くの場合、思慮深いフィードバックを提供しようとしながら、複数の言語、一貫性のない書式設定、および大きな差分を調整します。

GitHub Copilotは、**共同作業レビュー担当者とアシスタント**として機能することで、このワークロードを容易にするのに役立ちます。

### コードレビューにおけるCopilotの主な機能

| 機能 | 説明 |
|------|------|
| **PRの概要** | 変更の明確な概要と影響を受けるファイルの一覧を含むpull requestの説明を自動的に下書き |
| **セキュリティ修正** | GitHub Code Scanningと統合し、脆弱性に複数の言語でフラグを設定 |
| **行ごとの説明** | コードを強調表示し、Copilotに機能の説明を依頼して未知のコードを理解 |
| **コメントの下書き** | ベストプラクティスまたはチームのガイドラインに基づいてレビューコメントを生成 |
| **IDEでのレビュー** | pull requestを開く前にIDE内でコードをレビューし、問題を早期発見 |

### セキュリティ修正の例（JavaScript）

Copilotはセキュリティリスクを検出し、具体的な修正を提案します。

**検出例:**
```javascript
// 危険なコード
eval(userInput);  // ユーザー入力を使ったeval()はコードインジェクションを引き起こす可能性
```

**Copilotのフィードバック:**
> 「ユーザー入力を使ったeval()はコードインジェクションを引き起こす可能性があります。これをJSON.parse()のような安全なパーサーに置き換えてください。」

**推奨される修正:**
```javascript
// 安全なコード
const data = JSON.parse(userInput);
```

### PRの概要生成

Copilotは、pull requestの説明を自動生成し、レビュー担当者が推測ではなくコンテキストで始められるようにします。

**生成される内容:**
- 変更の明確な概要
- 影響を受けるファイルの一覧
- 主要な変更点のハイライト
- 潜在的な影響範囲

### まとめ

- Copilotはコードレビューの負担を軽減する協力的なアシスタント
- PR概要、セキュリティ修正、行ごとの説明などの機能を提供
- IDEでのレビューでPR作成前に問題を検出可能

---

## レクチャー2: コードレビューでのCopilot提案の活用
**時間目安: 12分**

### 学習目標
- コードレビューでCopilotの提案を効果的に使用する方法を理解する
- 複数の言語にわたるレビューの方法を把握する
- コードの説明とレビュー機能を活用できるようになる

### コードレビューでの提案の使用

pull requestをレビューするときに、改善できる可能性があるが完全な例やスニペットを自分で下書きする時間がない領域を見つける場合があります。GitHub Copilotは、著者の作品を引き継ぐことなく、そのギャップを埋めるのに役立ちます。

#### 提案の取得方法

1. pull requestの「ファイルが変更されました」ビューを開く
2. コードの行またはブロックを強調表示
3. Copilotに改善を提案するか、潜在的な問題にフラグを付けるよう依頼
4. Copilotが具体的なコンテキストに対応した提案を生成

#### Rubyコードの例

**質問:**
```
この繰り返しのコードに対して、よりクリーンなRubyリファクターを提案してください。
```

**Copilotの応答:**
一般的なRubyのベストプラクティスに従った更新バージョンを提案します。その推奨事項（またはその一部）を、自分の説明と共にレビューコメントに貼り付けることができます。

### 複数の言語にわたるレビュー

Copilotは複数のプログラミング言語に対応しており、言語の規則に沿った改善を迅速に生成します。

| 言語 | サポート例 |
|------|-----------|
| **JavaScript/TypeScript** | eval()のセキュリティ問題、Promise処理の改善 |
| **Python** | exec()の代替案、型ヒントの追加 |
| **Go** | 短い変数宣言への置き換え |
| **Ruby** | 繰り返しコードのリファクタリング |
| **Java** | ストリームAPIの活用提案 |

#### Goプログラムの例

Copilotは、Goプログラムで変数宣言を短い変数宣言（`:=`）に置き換えることを提案できます。

```go
// 変更前
var name string = "example"

// Copilotの提案後
name := "example"
```

### コードの説明とレビュー

#### 未知のコードの理解

pull requestのコードに慣れていない場合、Copilotに変更を説明するよう依頼できます。

**活用シーン:**
- 新しいプロジェクトへの参加時
- 馴染みのない言語やフレームワーク
- 複雑なアルゴリズムやビジネスロジック

#### 自己レビューの実行

チームメイトからのフィードバックを要求する前に、Copilotが独自のPRの初期レビューを実行することもできます。

**メリット:**
- 小さな問題を早期にキャッチ
- ベストプラクティスを検証
- 提出の品質に対する信頼度を向上

### GitHub.comでのCopilotレビュー担当者の使用方法

GitHub.comでは、Copilotのレビュー要求はレビュー担当者メニューから追加するのと同じくらい簡単です。数秒以内に、Copilotはコメントレビューを生成し、人間のレビュー担当者にとって貴重なコンテキストを追加します。

#### レビューの手順

| ステップ | 内容 | 詳細 |
|---------|------|------|
| 1 | **pull requestを開くか作成する** | 新しいPRを作成するか、既存のPRに移動 |
| 2 | **レビュー担当者としてCopilotを追加** | [校閲者]メニューから[Copilot]を選択 |
| 3 | **レビュー完了を待つ** | 通常30秒未満で完了 |
| 4 | **Copilotのコメントを確認** | 関連するコード行にコメントとして表示 |
| 5 | **推奨される変更を適用** | PRインターフェースから直接修正をコミット可能 |
| 6 | **制限を理解する** | Copilotの役割はアドバイザリ（承認・拒否はしない） |

#### Copilotの推奨される変更の適用例

Copilotが問題にフラグを立てると、PRインターフェースから直接修正をコミットできます。

**プロンプト例:**
```
このレビューコメントの修正候補: `exec()` をより安全な関数に置き換えます。
```

**Copilotの提案:**
```python
# subprocess.run() を使用したより安全な実装
import subprocess
result = subprocess.run(["command", "arg1"], capture_output=True, text=True)
```

#### copilot-instructions.mdによるカスタマイズ

リポジトリに`copilot-instructions.md`ファイルを追加することで、Copilotの動作をカスタマイズできます。

**カスタマイズのメリット:**
- チームの特定のレビュールールに従わせる
- 確認ポイントを統一
- 提案を基準に合わせる

#### Copilotレビューの制限

Copilotのレビューにおける役割は**アドバイザリ**です：

- pull requestを承認も拒否もしない
- コメントは必須の承認にカウントされない
- 問題の早期発見と実用的な提案の生成に使用
- アーキテクチャの決定、微妙なトレードオフ、最終的なサインオフは人間のレビュー担当者に依存

> **ポイント**: GitHub.comでの確認は強力ですが、IDEでCopilotを使用することで、コードがGitHubに到達する前にさらに多くの問題をキャッチできます。

### まとめ

- Copilotは具体的なコンテキストに対応したコード改善を提案
- 複数の言語にわたってレビューをサポート
- 未知のコードの説明や自己レビューにも活用可能
- GitHub.comで[校閲者]メニューからCopilotをレビュー担当者として追加可能
- Copilotのレビューはアドバイザリであり、最終判断は人間が行う

---

## レクチャー3: PRサマリー生成とデータ書式設定
**時間目安: 10分**

### 学習目標
- 有効なpull requestの概要（サマリー）を作成する方法を理解する
- PRにおけるデータの書式設定方法を把握する
- Copilotを使ったPR説明の効率化を実践できるようになる

### 有効なpull requestの概要の作成

PRの説明を書くことは、多くの場合、プロセスの最後のステップであり、ハードルのように感じることがあります。Copilotを使用すると、この作業が簡単になります。

#### PR概要の生成手順

1. PR説明エディターを開く
2. Copilotアイコンをクリック
3. 下書きの概要またはアウトラインを生成
4. 必要に応じて編集

**メリット:**
- 適切に構造化された開始点を取得
- 時間を節約
- レビュー担当者に必要な情報を確実に提供

### pull requestのデータの書式設定

pull requestは、メトリック、スクリーンショット、テスト結果などの適切な形式のコンテキストを含めると、はるかに明確になります。しかし、多くの場合、チームはこのコンテンツを一貫して書式設定することを忘れます。

#### Copilotによる書式設定支援

GitHub Copilotは、コードレビューの際に「第三者の目」として機能し、以下を行います：

- 不適切な形式のテーブルを自動で検出
- 会社のスタイルガイドラインに合ったより洗練されたバージョンを提案

#### テーブル書式設定の例

**元のテーブル（読みにくい）:**

| テスト実行 | LoadTimeBefore | LoadTimeAfter |
| --- | --- | --- |
|  | 1.3 | 1.2 |
|  | 1.2 | 1.1 |
|  | 1.1 | 0.885 |
| 平均 | 1.22 | 1.0806 |

**Copilotのコメント:**
> 「このテーブルは、リポジトリのMarkdownガイドラインに従っていません。会社のスタイルガイドに基づくクリーンアップバージョンを以下に示します。」

**修正されたテーブル:**

| テスト実行 | 事前の読み込み時間 (秒) | 更新後の読み込み時間 (秒) |
| --- | --- | --- |
| 1 | 1.3 | 1.2 |
| 2 | 1.2 | 1.1 |
| 3 | 1.1 | 0.885 |
| 4 | 1.3 | 1.3 |
| 5 | 1.2 | 0.918 |
| **平均** | **1.22** | **1.0806** |

### Copilotの役割

この例では、Copilotは**自動レビュー担当者**として機能しています（コーディングエージェントではなく）：

1. 書式設定されていないテーブルを検出
2. `.github/copilot-instructions.md`から会社のガイドラインを適用
3. 修正されたバージョンをインラインで提供

レビュー担当者はワンクリックでCopilotの提案を受け入れることができ、PRは再フォーマットに時間を費やすことなく会社のスタイルに従うことができます。

### マージ競合の解決

Copilotはブランチ間の競合の解決に関するガイダンスを提供し、マージプロセスを合理化します。

**支援内容:**
- 競合箇所の特定
- 解決方法の提案
- マージ戦略のアドバイス

### ドキュメント更新の自動提案

コードの変更に基づいて、READMEファイル、変更ログ、およびその他のドキュメントの更新を自動的に提案します。

**対象ドキュメント:**
- README.md
- CHANGELOG.md
- API ドキュメント
- インラインコメント

### PRU（Premium Request Units）消費量

> **注意**: PR概要の生成と高度なPull Request支援機能では、Premium Request Units（PRU）が使用されます。

#### PRU消費量の目安

| 操作 | PRU消費量 |
|------|----------|
| PRサマリー生成 | 1〜2 PRU（変更の複雑さとサイズに依存） |
| コードレビュー要求 | 1〜3 PRU（分析の範囲と複雑さに依存） |

**ベストプラクティス:**
- 毎月の許容量内に収まるように使用状況を監視
- 複雑なPRは分割してレビュー効率を向上
- 必要に応じてPRU使用量を確認

> PRUの使用量と制限の現在の詳細については、[GitHub Copilotのドキュメント](https://docs.github.com/en/copilot/concepts/billing/copilot-requests)を参照してください。

### まとめ

- Copilotを使ってPR概要を効率的に作成
- データやテーブルの書式設定を自動化
- 会社のスタイルガイドに沿った一貫したPRを実現
- マージ競合の解決ガイダンスでマージプロセスを効率化
- PRU使用量を意識して効率的に機能を活用

---

## レクチャー4: カスタムレビュー手順とセキュリティ修正
**時間目安: 10分**

### 学習目標
- カスタムレビュー手順（`.github/copilot-instructions.md`）の設定方法を理解する
- PRU（Premium Request Units）による高度な機能を把握する
- セキュリティ修正機能の活用方法を理解する

### PRUによる高度なレビュー機能のロック解除

PRU（Premium Request Units）は、高度なレビュー機能を強化します。

#### PRUを使用する主な機能

| 機能 | 説明 |
|------|------|
| **PRレビュー担当者としてのCopilot** | Copilotをレビュー担当者として割り当て |
| **カスタムレビュー手順** | チームルールに合わせた調整 |
| **詳細なコード分析** | 読みやすさ、セキュリティ、スタイルの重点分析 |

### カスタムレビュー手順の設定

カスタム`.github/copilot-instructions.md`ファイルを使用すると、PRUを利用したレビューは、チームのルールに合わせて調整されます。

#### 設定ファイルの例

```markdown
# Copilot レビュー手順

## コードスタイル
- インデントは2スペースを使用
- 変数名はキャメルケースを使用
- 関数は単一責任の原則に従う

## セキュリティ
- ユーザー入力は必ず検証する
- eval()やexec()の使用を避ける
- 機密情報をログに出力しない

## パフォーマンス
- N+1クエリを避ける
- 不要なループを最適化する
```

### Copilotなしとありのレビュー比較

#### Copilotなしの場合

レビュー担当者からのあいまいなコメント：
> 「ここでセキュリティの問題を修正する」

#### Copilot + PRUの場合

具体的で実用的なフィードバック：
> 「`exec()`を使用すると、コードインジェクションの脆弱性が発生します。コマンドの実行を安全にするために、`subprocess.run()`に置き換えることを検討してください。推奨されるパッチを次に示します:」

さらに、**コード修正をインラインで提供**します。

### セキュリティ修正機能

Copilotコードレビューは、GitHub Code Scanningと統合されると、脆弱性に複数の言語でフラグを設定します。

#### 対応言語とセキュリティチェック

| 言語 | 検出可能な脆弱性例 |
|------|-------------------|
| **JavaScript** | eval()への未承認入力、XSS脆弱性 |
| **Python** | exec()、pickle.loads()の危険な使用 |
| **SQL** | SQLインジェクション |
| **その他** | OWASP Top 10の各種脆弱性 |

### IDEでのレビュー機能

GitHub.comで直接作業するだけでなく、CopilotはIDE内のコードをレビューすることもできます。

**メリット:**
- pull requestを開く前に問題をキャッチして解決
- プロセスを高速化
- 再作業を削減

### まとめ

- `.github/copilot-instructions.md`でカスタムレビュー手順を設定
- PRUを使用して高度なレビュー機能を活用
- セキュリティ脆弱性を自動検出し、具体的な修正を提案
- IDEでのレビューでPR作成前に問題を解決

---

## レクチャー5: 自動レビューの設定とスケーリング
**時間目安: 12分**

### 学習目標
- VS CodeまたはJetBrains IDEでローカルCopilotレビューを使用できる
- パス固有のカスタム指示（`.github/instructions`フォルダ）を設定できる
- PRU（Premium Request Units）を活用した詳細分析を理解する
- ルールセットを使用した自動レビューを設定できる
- アカウント、リポジトリ、組織レベルでの自動レビューを構成できる

### IDEでのCopilotローカルレビュー

GitHub Copilotレビューは、pull requestを開くまで待つ必要はありません。VS CodeまたはJetBrains IDEでは、**コミットする前に変更を確認**するようCopilotに要求できます。

#### ローカルレビューのメリット

| メリット | 説明 |
|---------|------|
| **早期発見** | スタイル違反、セキュリティのギャップを早期に発見 |
| **サイクル短縮** | レビュープロセスのサイクルを節約 |
| **品質向上** | ベストプラクティスの問題に事前対処 |

#### レビューをガイドする設定ファイル

`.github/copilot-instructions.md`ファイルを作成してレビューをガイドします：

```markdown
# レビュー規則
- セキュリティに重点を置き、安全でない文字列補間を回避
- 関数にパラメーターと戻り値の型を説明するdocstringがあることを確認
```

Copilotはこれらのルールをレビューに自動的に適用し、より大きな差分を分析してリポジトリのスタイルに合ったコンテキストに富んだ分析情報を提供します。

#### ユースケース例

開発者がTypeScriptサービスに繰り返しコードを追加した場合：
1. Copilotがそれを識別
2. ヘルパー関数の抽出を提案
3. 開発者はコードをプッシュする前に問題を修正
4. 後のレビューにおけるノイズを軽減

### パス固有のカスタム指示

パス固有のカスタム指示を使用して、特定のファイルやフォルダーのCopilotコードレビューまたはコーディングエージェントをガイドできます。

#### 設定手順

| ステップ | 内容 | 詳細 |
|---------|------|------|
| 1 | **instructionsディレクトリを作成** | `.github/instructions`フォルダを追加 |
| 2 | **命令ファイルを追加** | `.instructions.md`で終わるファイルを作成（例：`security.instructions.md`） |
| 3 | **適用するパスを定義** | `applyTo`キーワードを使用してfrontmatterブロックを追加 |
| 4 | **カスタムガイダンスを記述** | Markdownでレビューガイダンスを追加 |

#### applyToキーワードの例

```yaml
# Rubyモデルに適用
applyTo: "app/models/**/*.rb"

# TypeScriptファイルに適用
applyTo: "**/*.ts,**/*.tsx"

# リポジトリ内のすべてのファイルに適用
applyTo: "**"
```

### IDEでのPRU活用

Visual Studio CodeやJetBrains IDEでCopilotレビューを実行する場合、GitHub.comで使用できる軽量チェックに限定されません。

#### PRU（Premium Request Units）を活用した詳細分析

| 機能 | 説明 |
|------|------|
| **高度なモデル活用** | より高度なモデルを活用した分析 |
| **大きな差分の分析** | より大きなコード差分を分析可能 |
| **カスタム命令の適用** | リポジトリのカスタム命令を適用 |
| **高品質な提案** | PR作成前に高品質の提案を提示 |

#### メリット

- 開発サイクルの早い段階でスタイル違反、セキュリティギャップ、ベストプラクティスの問題を発見
- 正式なレビュー中の時間を節約
- チームメイトとの往復を削減
- 最終的な判断とサインオフは人間のレビュー担当者に委ねつつ、より深い分析が可能

### ルールセットを使用した自動レビュー

手動レビューは、動きの速いチームではうまくスケールしません。GitHubでは、保護されたブランチを対象とするすべてのPRにCopilotを自動的に割り当てるルールセットを構成できます。

#### 自動レビューパイプラインの構成

Copilotレビューをテストやコードスキャンなどの状態チェックとペアリングすることで、パイプラインを作成できます：

| コンポーネント | 役割 |
|--------------|------|
| **Copilotレビュー** | スタイルと読みやすさを確認 |
| **コードスキャン** | 脆弱性を検出 |
| **テスト** | 機能を検証 |

#### PRU消費の管理

各Copilotレビューではプレミアムリクエストユニット（PRU）が使用されます：

- 組織はPRU消費量を予算化してレビューの量を一致させる
- 開発プロセスの適切な時期に自動レビューを実行する
- 使用状況の追跡でコストとカバレッジのバランスを取る

### アカウントの自動レビュー設定

> **注**: このオプションはCopilot ProまたはCopilot Pro+プランでのみ使用可能

個人用のCopilot設定でこの機能を有効にすると、開いたすべてのPRが自動的にレビューされます。

#### 設定手順

1. GitHubページの右上隅にあるプロファイル画像をクリック
2. 「自分のCopilot」を選択
3. 「自動コパイロットコードレビュー」のオプションを見つける
4. ドロップダウンから「有効」を選択

### リポジトリの自動レビュー設定

より厳密な品質管理が必要な特定のリポジトリでのみ自動レビューを設定する場合、リポジトリ管理者がブランチルールセットを作成できます。

#### 設定手順

| ステップ | 操作 |
|---------|------|
| 1 | リポジトリで「設定」をクリック |
| 2 | サイドバーで「コードと自動化」→「ルール」→「ルールセット」を選択 |
| 3 | 「新しいルールセット」→「新しい分岐ルールセット」をクリック |
| 4 | 名前を入力し、「強制状態」を「アクティブ」に設定 |
| 5 | ターゲットブランチ（デフォルトブランチなど）を選択 |
| 6 | 「分岐ルール」で「マージする前にpull requestを要求する」をオン |
| 7 | 「Copilotからpull requestレビューを要求する」を選択 |
| 8 | 「作成」をクリック |

#### 追加オプション

「マージする前に会話の解決を要求する」を有効にすると、開発者がCopilotからのフィードバックを読み取るよう促すことができます。

### 組織全体の自動レビュー設定

大規模なチームでは、このアプローチを複数のリポジトリに一度にスケーリングできます。組織の所有者は、名前パターンまたは包含/除外規則に基づいて、選択したリポジトリに適用されるルールセットを作成できます。

#### 設定手順

| ステップ | 操作 |
|---------|------|
| 1 | GitHubの右上隅にあるプロファイル画像をクリックし、「組織」を選択 |
| 2 | 組織を選択し、「設定」に移動 |
| 3 | サイドバーで「リポジトリ」→「ルールセット」を選択 |
| 4 | 「新しい規則セット」→「新しい分岐ルールセット」をクリック |
| 5 | ルールセット名を指定し、「強制状態」を「アクティブ」に設定 |
| 6 | 包含または除外パターンを指定してターゲットリポジトリを追加（例：`*service`） |
| 7 | ターゲットブランチを定義 |
| 8 | 「マージする前にプルリクエストを要求する」と「Copilotからのプルリクエストレビューを要求する」を有効化 |
| 9 | 「作成」をクリックして保存 |

#### 組織レベルでの自動レビューのメリット

- 一貫した標準を保証
- 組織全体のレビュー時間を短縮
- 小規模な修正や依存関係の更新も一貫してレビュー
- 気付かれていない回帰のリスクを軽減

### まとめ

- IDEでコミット前にCopilotレビューを実行し、問題を早期発見
- `.github/instructions`フォルダでパス固有のカスタム指示を設定
- PRUを活用してIDEでより詳細な分析を実行
- ルールセットを使用して自動レビューをスケーリング
- アカウント、リポジトリ、組織レベルで自動レビューを構成可能

---

## レクチャー6: 影響の測定とPRUの最適化
**時間目安: 10分**

### 学習目標
- PRUを定義し、Copilotの高度なレビュー機能を有効にする方法を説明できる
- PRUを利用したレビューがワークフローに与える影響を測定できる
- 予算に戦略を適用し、最大値を得るためにPRUを最適化できる

### PRUについて

Premium Request Units（PRU）は、Copilotの「追加装備」のロックを解除するトークンと考えることができます。1行に対する小さなリファクタリング提案のような軽量なタスクでは、多くの場合PRUは使用されません。しかし、プレミアムレベルのタスクには該当します。

#### PRU使用時とPRU不使用時の違い

| 項目 | PRUなし | PRUあり |
|------|---------|---------|
| **提案の深さ** | デフォルトの軽量な提案のみ | コンテキストに富んだ詳細な分析 |
| **差分の分析範囲** | 限定的 | 差分全体をスキャン |
| **カスタムガイドライン** | 適用なし | カスタムレビューガイドラインを解釈 |
| **レスポンス時間** | 高速 | 数秒で実行可能な修正を返却 |

#### シナリオ例: 大規模リファクタリングのレビュー

開発者が多数のファイルに触れる大規模なリファクタリングをプッシュした場合：

1. レビュー担当者として割り当てられたCopilotがPRUを使用
2. リポジトリのセキュリティとスタイルのガイドラインを変更全体に適用
3. 安全でない文字列補間にフラグを設定
4. 問題を説明するMarkdownコメントの下書きを作成

**結果**: 人間の校閲者は手動チェックに時間を費やす代わりに、リファクタリングのアーキテクチャへの影響に集中できます。

### チームにとってPRUが重要な理由

PRUは、大量の環境でCopilotを真にスケーラブルにします。

| 機能 | 説明 |
|------|------|
| **より深い分析の実施** | 本番環境に到達する前に、大規模な差分の中から微細な脆弱性、重複したロジック、スタイル違反などを検出 |
| **一貫性の強制** | すべてのPRに対して同じセキュリティ、読みやすさ、スタイルチェックを自動的に適用 |
| **アクティビティバーストの処理** | 忙しいリリースサイクル中はPRUを利用したレビューで品質を安定させ、人間のレビュー担当者が複雑な設計上の決定を処理 |

#### シナリオ例: マイクロサービスアーキテクチャでの多言語レビュー

チームがGo、Python、TypeScriptでマイクロサービスアーキテクチャを維持している場合：

- **プレリリースのクランチ中**: CopilotがPRUを使用して各サービスを言語固有のベストプラクティスについて確認
- **JavaScriptでの検出**: 危険な`eval()`呼び出しにフラグを設定し、より安全なパーサーを推奨
- **Goでの検出**: ハンドラーで不足しているエラーチェックをキャッチ

**結果**: チームは重要な詳細を見逃すことなく、すべてのサービスで迅速に修正プログラムをマージできます。

### PRUを利用したレビューの影響測定

PRUのリターンを理解するには、以下のようなメトリックを追跡します。

| メトリック | 説明 | 測定方法 |
|-----------|------|---------|
| **PRリードタイム** | PRがオープンからマージまでにかかる時間 | Copilotによるレビュー追加前後で比較 |
| **品質指標** | マージ後のセキュリティまたはスタイルの問題 | 他のツールによって指摘された問題の削減率 |
| **開発者エクスペリエンス** | Copilotがレビューをより迅速・明確にするか | チームからのフィードバック収集 |

#### メトリックの例

| 項目 | PRU導入前 | PRU導入後 |
|------|----------|----------|
| 大規模PRのマージ時間 | 平均3日 | 平均1日 |
| リリース後のスタイル修正 | 頻発 | 大幅削減 |
| フォローアップコミット | 多い | はるかに少ない |

### PRU使用の最適化

PRUを管理することで、最も価値の高い場所にPRUを使用できるようになります。

#### 最適化戦略

| 戦略 | 説明 |
|------|------|
| **事前に計画する** | 75%、90%、100%の月間PRU使用量に達したときにアラートを設定 |
| **PRUを戦略的に使用する** | 大規模または高リスクの変更に対するプレミアムレビューを予約し、単純な編集には標準的なCopilotの提案に依存 |
| **プロンプトを調整する** | クリーンで特定の要求により、不要な再試行と無駄なPRUを削減 |
| **必要に応じてスケールアップ** | チームが一貫してPRUを最大限に引き出している場合は、ワークロードをサポートする上位レベルのCopilotプランを検討 |

#### シナリオ例: PRU使用量の最適化

チームが多くのPRUが簡単なドキュメント変更に費やされていることに気付いた場合：

1. **問題の特定**: ドキュメント変更にPRUを使用
2. **ワークフローの更新**: 小規模な編集にPRU以外の要求を使用
3. **プレミアムレビューの予約**: 運用環境に影響を与えるコードのみに適用

**結果**: 毎月のPRU使用量は品質を損なうことなく30%低下

### まとめ

- PRUはCopilotの高度なレビュー機能を可能にするトークン
- チームはPRUを使用してより深くコンテキストに富んだレビューを提供可能
- PRリードタイム、品質指標、開発者エクスペリエンスでPRUの影響を測定
- 事前計画、戦略的使用、プロンプト調整でPRU使用を最適化
- 最終的な判断とサインオフは人間のレビュー担当者に任せながら、高品質のコードレビューをスケーリング可能

---

## 確認テスト: コードレビューとPull Request

### 問題1
GitHub Copilotがコードレビューで提供する主な機能として**正しくない**ものはどれですか？

- A) PRの概要を自動生成する
- B) セキュリティ脆弱性を検出してフラグを付ける
- C) アプリケーションを自動的にデプロイする
- D) 行ごとのコード説明を提供する

<details>
<summary>解答</summary>

**正解: C) アプリケーションを自動的にデプロイする**

GitHub Copilotのコードレビュー機能には、PRの概要生成、セキュリティ修正、行ごとの説明、コメントの下書き、IDEでのレビューなどが含まれます。アプリケーションのデプロイは、GitHub ActionsやCI/CDツールの役割であり、Copilotのコードレビュー機能には含まれません。

</details>

---

### 問題2
Copilotをチームのルールに合わせてカスタマイズするために使用するファイルはどれですか？

- A) `.github/CODEOWNERS`
- B) `.github/copilot-instructions.md`
- C) `.copilot/config.json`
- D) `copilot.yml`

<details>
<summary>解答</summary>

**正解: B) `.github/copilot-instructions.md`**

カスタム`.github/copilot-instructions.md`ファイルを使用すると、PRUを利用したレビューがチームのルール（読みやすさ、セキュリティ、スタイルなど）に合わせて調整されます。

</details>

---

### 問題3
JavaScriptコードでCopilotが検出し、修正を提案する可能性のあるセキュリティ脆弱性はどれですか？

- A) 未使用の変数
- B) eval()への未承認入力
- C) コメントの欠如
- D) 長い関数名

<details>
<summary>解答</summary>

**正解: B) eval()への未承認入力**

Copilotはeval()にユーザー入力を渡すコードを検出し、「ユーザー入力を使ったeval()はコードインジェクションを引き起こす可能性があります。これをJSON.parse()のような安全なパーサーに置き換えてください」といったフィードバックを提供します。

</details>

---

### 問題4
IDEでCopilotレビューを使用する主な利点は何ですか？

- A) コードの実行速度が向上する
- B) pull requestを開く前に問題をキャッチして解決できる
- C) 自動的にコードがマージされる
- D) GitHubアカウントなしで使用できる

<details>
<summary>解答</summary>

**正解: B) pull requestを開く前に問題をキャッチして解決できる**

IDEでのCopilotレビュー機能を使用すると、開発者はpull requestを開く前に問題をキャッチして解決でき、プロセスを高速化し、再作業を減らすことができます。

</details>

---

### 問題5
Copilotがpull requestのデータ書式設定で支援できることはどれですか？

- A) 画像ファイルを自動圧縮する
- B) 不適切な形式のテーブルを検出し、スタイルガイドに沿った形式を提案する
- C) GitHubリポジトリを自動的に作成する
- D) コードを別の言語に翻訳する

<details>
<summary>解答</summary>

**正解: B) 不適切な形式のテーブルを検出し、スタイルガイドに沿った形式を提案する**

Copilotはコードレビューの際に「第三者の目」として機能し、不適切な形式のテーブルを自動で検出し、`.github/copilot-instructions.md`から会社のガイドラインを適用して、修正されたバージョンをインラインで提供します。

</details>

---

### 問題6
PRU（Premium Request Units）を使用するCopilot機能はどれですか？

- A) 基本的なコード補完
- B) PRレビュー担当者としてCopilotを割り当てる
- C) ファイルの保存
- D) テキストの検索と置換

<details>
<summary>解答</summary>

**正解: B) PRレビュー担当者としてCopilotを割り当てる**

PRレビュー担当者としてCopilotを割り当てると、コメントを投稿するたびにPRU（Premium Request Units）が使用されます。カスタム`.github/copilot-instructions.md`ファイルと組み合わせることで、チームのルールに合わせた高度なレビューが可能になります。

</details>

---

### 問題7
GitHub.comでCopilotをレビュー担当者として追加するには、どこから選択しますか？

- A) [設定]メニュー
- B) [校閲者]メニュー
- C) [アクション]メニュー
- D) [セキュリティ]タブ

<details>
<summary>解答</summary>

**正解: B) [校閲者]メニュー**

GitHub.comでpull requestをレビューする際、[校閲者]メニューから[Copilot]を選択することで、Copilotをレビュー担当者として追加できます。これにより、人間のチームメイトを割り当てるのと同様に、Copilotが変更を確認できるようになります。

</details>

---

### 問題8
CopilotがGitHub.comでpull requestのレビューを完了するのに通常どのくらいの時間がかかりますか？

- A) 5〜10分
- B) 1〜2分
- C) 30秒未満
- D) 即時（0秒）

<details>
<summary>解答</summary>

**正解: C) 30秒未満**

Copilotはpull requestの分析をすぐに開始し、通常レビューは30秒未満で完了します。これにより、ワークフローを中断することなくすばやく結果を得ることができます。

</details>

---

### 問題9
GitHub.comでのCopilotレビューの役割として**正しい**ものはどれですか？

- A) pull requestを自動的に承認する
- B) マージをブロックする権限を持つ
- C) アドバイザリとしてコメントを提供する
- D) 必須の承認としてカウントされる

<details>
<summary>解答</summary>

**正解: C) アドバイザリとしてコメントを提供する**

Copilotのレビューにおける役割はアドバイザリです。pull requestを承認も拒否もせず、そのコメントは必須の承認にカウントされません。問題を早期にキャッチし、実用的な提案を生成しますが、アーキテクチャの決定や最終的なサインオフは人間のレビュー担当者に依存します。

</details>

---

### 問題10
Copilotのレビュー動作をカスタマイズするためにリポジトリに追加するファイルはどれですか？

- A) .github/CODEOWNERS
- B) .github/workflows/copilot.yml
- C) copilot-instructions.md
- D) .copilotrc

<details>
<summary>解答</summary>

**正解: C) copilot-instructions.md**

リポジトリに`copilot-instructions.md`ファイルを追加することで、Copilotの動作をカスタマイズできます。これらの指示により、Copilotがチームの特定のレビュールールに従い、同じポイントを確認し、提案が基準に合うようにできます。

</details>

---

### 問題11
パス固有のカスタム指示を設定するために作成するフォルダはどれですか？

- A) `.github/copilot`
- B) `.github/instructions`
- C) `.copilot/rules`
- D) `.github/reviews`

<details>
<summary>解答</summary>

**正解: B) `.github/instructions`**

パス固有のカスタム指示を設定するには、リポジトリのルートに`.github/instructions`フォルダを作成し、`.instructions.md`で終わるファイル（例：`security.instructions.md`）を追加します。

</details>

---

### 問題12
パス固有のカスタム指示ファイルで、指示を適用するファイルパスを指定するために使用するキーワードはどれですか？

- A) `targetPath`
- B) `includePath`
- C) `applyTo`
- D) `fileMask`

<details>
<summary>解答</summary>

**正解: C) `applyTo`**

各命令ファイルの先頭にfrontmatterブロックを追加し、`applyTo`キーワードを使用して、これらの指示を適用するファイルやディレクトリをglob構文で指定します。例：`applyTo: "**/*.ts,**/*.tsx"`

</details>

---

### 問題13
リポジトリで自動Copilotレビューを設定するために使用するGitHub機能はどれですか？

- A) GitHub Actions
- B) ブランチルールセット
- C) Webhooks
- D) GitHub Apps

<details>
<summary>解答</summary>

**正解: B) ブランチルールセット**

リポジトリ管理者はブランチルールセットを作成することで、保護されたブランチを対象とするすべてのPRにCopilotを自動的に割り当てることができます。「設定」→「コードと自動化」→「ルール」→「ルールセット」から設定します。

</details>

---

### 問題14
個人のCopilot設定で自動レビューを有効にできるのは、どのプランのユーザーですか？

- A) Copilot Freeのみ
- B) Copilot Businessのみ
- C) Copilot ProまたはCopilot Pro+
- D) すべてのCopilotプラン

<details>
<summary>解答</summary>

**正解: C) Copilot ProまたはCopilot Pro+**

アカウントの自動レビューオプションは、Copilot ProまたはCopilot Pro+プランを使用している場合にのみ使用できます。個人用のCopilot設定で「自動コパイロットコードレビュー」を有効にすると、開いたすべてのPRが自動的にレビューされます。

</details>

---

### 問題15
PRU導入効果を測定するために追跡すべきメトリックとして**正しくない**ものはどれですか？

- A) PRリードタイム
- B) マージ後のセキュリティ問題の削減
- C) コードの行数
- D) 開発者エクスペリエンス

<details>
<summary>解答</summary>

**正解: C) コードの行数**

PRUのリターンを理解するために追跡すべきメトリックには、PRリードタイム（PRがオープンからマージまでにかかる時間）、品質指標（マージ後のセキュリティまたはスタイル問題の削減）、開発者エクスペリエンス（Copilotがレビューをより迅速・明確にするかに関するフィードバック）が含まれます。コードの行数はPRU効果の測定には使用されません。

</details>

---

### 問題16
PRU使用を最適化するための戦略として**正しい**ものはどれですか？

- A) すべてのPRでPRUを利用したレビューを使用する
- B) 大規模または高リスクの変更に対してプレミアムレビューを予約する
- C) PRUの使用量を追跡しない
- D) 常に最も詳細なプロンプトを使用する

<details>
<summary>解答</summary>

**正解: B) 大規模または高リスクの変更に対してプレミアムレビューを予約する**

PRUを戦略的に使用するには、大規模または高リスクの変更に対するプレミアムレビューを予約し、単純な編集には標準的なCopilotの提案に依存することが推奨されます。これにより、最も価値の高い場所にPRUを使用できます。

</details>

---

### 問題17
PRUを使用すると可能になる分析として**正しくない**ものはどれですか？

- A) 大規模な差分の中から微細な脆弱性を検出
- B) すべてのPRに対して同じセキュリティチェックを自動適用
- C) コードを自動的に本番環境にデプロイ
- D) 活動のバースト時に品質を安定させる

<details>
<summary>解答</summary>

**正解: C) コードを自動的に本番環境にデプロイ**

PRUを使用すると、より深い分析の実施（大規模な差分から微細な脆弱性を検出）、一貫性の強制（すべてのPRに同じセキュリティチェックを適用）、アクティビティバーストの処理（忙しいリリースサイクル中に品質を安定）が可能になります。しかし、本番環境へのデプロイはPRUの機能ではなく、CI/CDパイプラインの役割です。

</details>

---

### 問題18
PRUの月間使用量に対してアラートを設定する推奨タイミングはどれですか？

- A) 50%と100%
- B) 75%、90%、100%
- C) 25%、50%、75%、100%
- D) 100%のみ

<details>
<summary>解答</summary>

**正解: B) 75%、90%、100%**

PRU使用を事前に計画するために、75%、90%、100%の月間PRU使用量に達したときにアラートを設定することが推奨されます。これにより、予算を超過する前に使用パターンを調整できます。

</details>
